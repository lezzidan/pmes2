/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf


#define ARGS_OFFSET 2


static FILE *workerFile = NULL;
static char *perl_binary = "/usr/bin/perl";
static char *perl_extension_dir = NULL;


void set_perl_binary(char const * newBinary)
{
	perl_binary = strdup(newBinary);
}


void set_perl_extension_dir(char const * ext)
{
	perl_extension_dir = strdup(ext);
}


void generate_perl_prolog()
{
	char name[PATH_MAX];
	
	debug_printf("Perl: Generate prolog\n");
	
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-worker.pl", PATH_MAX);
	rename_if_clash(name);
	workerFile = fopen(name, "w");
	if (workerFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}
	fchmod(fileno(workerFile), 0750);

	fprintf(workerFile, "#!%s -I..\n", perl_binary);
	fprintf(workerFile, "\n");
	fprintf(workerFile, "# This file has been autogenerated from '%s'.\n", get_filename());
	fprintf(workerFile, "# Generator component: $Id: perl-backend.c,v 1.8 2004/06/16 09:25:31 perez Exp $\n");
	fprintf(workerFile, "# CHANGES TO THIS FILE WILL BE LOST\n");
	fprintf(workerFile, "\n");

	if (perl_extension_dir != NULL) {
		fprintf(workerFile, "use lib '%s';\n", perl_extension_dir);
		fprintf(workerFile, "\n");
	}
	
	fprintf(workerFile, "use strict;\n");
	fprintf(workerFile, "use warnings;\n");
	fprintf(workerFile, "use MIME::Base64;\n");
	fprintf(workerFile, "use GSWorker;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "use %s_functions;\n", get_filename_base());
	fprintf(workerFile, "\n");

	fprintf(workerFile, "unshift(@ARGV, $0);\n");
	fprintf(workerFile, "\n");
	
	fprintf(workerFile, "my $opCod = $ARGV[2];\n");
	fprintf(workerFile, "$GSWorker::gs_result = 0;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "GSWorker::IniWorker(int(@ARGV), \\@ARGV);\n");
	fprintf(workerFile, "\n");
}


void generate_perl_epilogue(void)
{
	debug_printf("Perl: Generate epilogue\n");
	
	fprintf(workerFile, "} else {\n");
	fprintf(workerFile, "  croak(\"Unknown operation code.\");\n");
	fprintf(workerFile, "  $GSWorker::gs_result = -1;\n");
	fprintf(workerFile, "}\n");
	fprintf(workerFile, "\n");
	
	fprintf(workerFile, "GSWorker::EndWorker($GSWorker::gs_result, int(@ARGV), \\@ARGV);\n");
	fprintf(workerFile, "\n");

	fclose(workerFile);
}



/* Note: requires passing_(in/out)_order to be set (by generate_execute_call) */
static void generate_worker_case(FILE *outFile, function *func, int func_id, int is_first)
{
	argument *arg;
	int is_first_arg = 1;
	int arg_number;
	
	debug_printf("\n*** Function %s\n", func->name);
	
	if (is_first) {
		fprintf(outFile, "if ");
	} else {
		fprintf(outFile, "} elsif ");
	}
	fprintf(outFile, "($opCod == %i) {\n", func_id);
	
	/* Declare all parameters */
	arg = func->first_argument;
	while (arg != NULL) {
		fprintf(outFile, "  my $%s;\n", arg->name);
		arg = arg->next_argument;
	}	
	fprintf(outFile, "\n");
	
	/* Fill in and inout generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "  $%s = $ARGV[%i];\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case file_dt:
					fprintf(outFile, "  $%s = $ARGV[%i];\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "  $%s = $ARGV[%i];\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					fprintf(outFile, "  $%s =~ s/-/=/g;\n", arg->name);
					fprintf(outFile, "  $%s = MIME::Base64::decode($%s);\n", arg->name, arg->name);
					fprintf(outFile, "  $%s = substr($%s, 0, -1);\n", arg->name, arg->name); /* Eat the null character at the end */
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
				
		}
		arg = arg->next_argument;
	}
	
	/* Fill out filenames */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->type == file_dt && arg->dir == out_dir) {
			fprintf(outFile, "  $%s = $ARGV[%i];\n", arg->name, arg->passing_out_order + ARGS_OFFSET);
		}
		arg = arg->next_argument;
	}
	fprintf(outFile, "\n");
	
	
	/* Make the call */
	fprintf(outFile, "  %s_functions::%s(", get_filename_base(), func->name);

	arg = func->first_argument;
	while (arg != NULL) {
		if (is_first_arg) {
			is_first_arg = 0;
		} else {
			fprintf(outFile, ", ");
		}
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case file_dt:
					fprintf(outFile, "$%s", arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "$%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		} else { /* out_dir || inout_dir */
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "\\$%s", arg->name);
					break;
				case file_dt:
					fprintf(outFile, "$%s", arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "\\$%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, ");\n");
	
	fprintf(outFile, "\n");
	
	/* Marshall out/inout generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == inout_dir || arg->dir == out_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "  $%s = $%s . \"\\0\";\n", arg->name, arg->name); /* Add a null character at the end */
					fprintf(outFile, "  $%s = MIME::Base64::encode($%s, \"\");\n", arg->name, arg->name);
					fprintf(outFile, "  $%s =~ s/=/-/g;\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
				
		}
		arg = arg->next_argument;
	}

	/* Set generics in order */
	for (arg_number = 1; arg_number <= func->exec_arg_count; arg_number++)
	{
		arg = func->first_argument;
		while (arg != NULL) {
			if (arg->passing_out_order == arg_number &&
				(arg->dir == inout_dir || arg->dir == out_dir)) {
				switch (arg->type) {
					case char_dt:
					case wchar_dt:
					case boolean_dt:
					case short_dt:
					case long_dt:
					case longlong_dt:
					case int_dt:
					case float_dt:
					case double_dt:
						fprintf(outFile, "  GSWorker::leaveDestGen($%s);\n", arg->name);
						break;
					case file_dt:
						break;
					case string_dt:
					case wstring_dt:
						fprintf(outFile, "  GSWorker::leaveDestGen($%s);\n", arg->name);
						break;
					case void_dt:
					case any_dt:
					case null_dt:
					default:
						;
				}
			}
			arg = arg->next_argument;
		}
	}
		
}	
			

void generate_perl_body(void)
{
	function *current_function;
	int is_first = 1;
	int func_id = 0;
	
	debug_printf("Generate body\n");
	
	current_function = get_first_function();
	while (current_function != NULL) {
		generate_worker_case(workerFile, current_function, func_id, is_first);
		func_id++;
		is_first = 0;

		current_function = current_function->next_function;
	}
}

