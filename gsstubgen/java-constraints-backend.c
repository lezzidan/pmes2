/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"

static const char cvs_file_id[]="$Id: c-constraints-backend.c,v 1.2 2004/11/19 10:00:34 perez Exp $";


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf

static FILE *constraintsFile = NULL;
static FILE *interfaceFile = NULL;
static FILE *wrapperFile = NULL;
static char interfaceName[PATH_MAX];

static char *java_types[] = { "void", "char", "char", "int", "void *", "short",
	"long", "int", "float", "double", "String", "String", "String", "error" };

void generate_java_constraints_prolog(void)
{
	char name[PATH_MAX];
	char *c;
	
	debug_printf("Generate Java constraints prolog\n");
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "Constraints.java", PATH_MAX);
	constraintsFile = create_without_overwrite(name);
	if (constraintsFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	rename_if_clash("ConstraintsWrapper.java");
	wrapperFile = fopen("ConstraintsWrapper.java", "w");
	if (wrapperFile == NULL) {
		fprintf(stderr, "Error: Could not open ConstraintsWrapper.java for writing.\n");
		exit(1);
	}

	strncpy(interfaceName, get_filename_base(), PATH_MAX);
	strncat(interfaceName, "ConstraintsInterface.java", PATH_MAX);
	rename_if_clash(interfaceName);
	interfaceFile = fopen(interfaceName, "w");
	if (interfaceFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", interfaceName);
		exit(1);
	}
	// Comments in the begining of the class files
	fprintf(constraintsFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(constraintsFile, "/* You can customize this file to your needs */\n");
	fprintf(constraintsFile, "\n");
	
	fprintf(wrapperFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(wrapperFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(wrapperFile, "\n");
	
	fprintf(interfaceFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(interfaceFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(interfaceFile, "\n");
	fprintf(interfaceFile, "/* Interface that should be implemented by '%sConstraints.java'. */\n", get_filename_base());
	fprintf(interfaceFile, "\n");

	// Begining of the definitions
	fprintf(constraintsFile, "public class %sConstraints implements %sConstraintsInterface\n",
		get_filename_base(), get_filename_base() ); 
	fprintf(constraintsFile, "{\n");	

	fprintf(interfaceFile, "public interface %sConstraintsInterface\n", get_filename_base());
	fprintf(interfaceFile, "{\n");

	fprintf(wrapperFile, "public class ConstraintsWrapper\n");
	fprintf(wrapperFile, "{\n");
	fprintf(wrapperFile, "	private final int Ops = %d;\n", get_function_count() );
	fprintf(wrapperFile, "	protected int getOps() { return Ops; }\n");
	fprintf(wrapperFile, "	private %sConstraints %sConstraintsInstance;\n", get_filename_base(), get_filename_base());
	fprintf(wrapperFile, "\n");
	fprintf(wrapperFile, "	ConstraintsWrapper ()\n");
	fprintf(wrapperFile, "	{\n");
	fprintf(wrapperFile, "		%sConstraintsInstance = new %sConstraints();\n", get_filename_base(), get_filename_base());
	fprintf(wrapperFile, "	}\n");
	fprintf(wrapperFile, "\n");
}


static void generate_java_constraints_call_parameters(FILE *outFile, function *func)
{
	argument *arg;
	int is_first_arg = 1;
	
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			if (!is_first_arg) {
				fprintf(outFile, ", ");
			}
			fprintf(outFile, "%s", arg->name);
			is_first_arg = 0;
		}
		arg = arg->next_argument;
	}
}


static void generate_java_constraints_prototype(FILE *outFile, function *func, char *suffix, char *return_type)
{
	argument *arg;
	int is_first_arg = 1;

	fprintf(outFile, "%s %s_%s(", return_type, func->name, suffix);
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			if (!is_first_arg) {
				fprintf(outFile, ", ");
			}
			fprintf(outFile, "%s ", java_types[arg->type]);
			fprintf(outFile, "%s", arg->name);
			is_first_arg = 0;
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, ")");
}


static void generate_java_constraints_skeletons(FILE *constraintsFile, function *current_function)
{
		generate_java_constraints_prototype(constraintsFile, current_function, "constraints", "\tpublic String");
		fprintf(constraintsFile, "\n");
		fprintf(constraintsFile, "\t{\n");
		fprintf(constraintsFile, "\t\treturn \"true\";\n");
		fprintf(constraintsFile, "\t}\n");
		fprintf(constraintsFile, "\n");
		
		generate_java_constraints_prototype(constraintsFile, current_function, "cost", "\tpublic double");
		fprintf(constraintsFile, "\n");
		fprintf(constraintsFile, "\t{\n");
		fprintf(constraintsFile, "\t\treturn 1.0;\n");
		fprintf(constraintsFile, "\t}\n");
		fprintf(constraintsFile, "\n");
}

static void generate_java_constraints_parameter_demarshalling(FILE *outFile, function *func, int _case, char *suffix)
{
	argument *arg;
	int index, isfirst;
	
	// Check if we need to demarshall the input parameters because 
	// we have only input parameters in the constraints functions
	fprintf(outFile,"\t\t\tcase %d:\n", _case);
	fprintf(outFile,"\t\t\t{\n");
	index = 0;
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			if ( ( arg->type == string_dt ) || ( arg->type == wstring_dt ) || ( arg->type == file_dt ) )
			{
				fprintf(outFile, "\t\t\t\tString param_%s = args[%d];\n", arg->name, index );
			}
			else
			{
				fprintf(outFile, "\t\t\t\tString str_%s = args[%d];\n", arg->name, index );
			}
			
				index++;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n\t\t\t\t/* Parameter demarshalling */\n");

	/* Convert output parameters */
	index = 0;
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "\t\t\t\tchar param_%s = str_%s.charAt(0);\n", arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "\t\t\t\tboolean param_%s = Boolean.valueOf(str_%s).booleanValue();\n", arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "\t\t\t\tshort param_%s = Short.parseShort(str_%s);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "\t\t\t\tlong param_%s = Long.parseLong(str_%s);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "\t\t\t\tlong param_%s = Long.parseLong(str_%s);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "\t\t\t\tint param_%s = Integer.parseInt(str_%s);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "\t\t\t\tfloat param_%s = Float.parseFloat(str_%s);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "\t\t\t\tdouble param_%s = Double.parseDouble(str_%s);\n", arg->name, arg->name);
					break;
				case file_dt:
				case string_dt:
				case wstring_dt:
					/* No conversion needed */
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
			index++;
		}
		arg = arg->next_argument;
	}
	fprintf(outFile, "\n");
	fprintf(outFile, "\t\t\t\t%s = %sConstraintsInstance.%s_%s( ", suffix, get_filename_base(), func->name, suffix );
	isfirst = 1;	
	index = 0;
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			if ( isfirst )
			{
				fprintf(outFile, " param_%s", arg->name );
				isfirst = 0;
			}
			else
			{
				fprintf(outFile, ", param_%s", arg->name );
			}
			index++;
		}
		arg = arg->next_argument;
	}
	fprintf(outFile, " );\n");
	fprintf(outFile, "\t\t\t\tbreak;\n");
	fprintf(outFile, "\t\t\t}\n");
}


void generate_java_constraints_body(void)
{
	int _case;
	function *current_function;
	debug_printf("Generate Java constraints body\n");
	
	fprintf(wrapperFile, "\tpublic String constraints_function ( int OpId, String args [] )\n");
	fprintf(wrapperFile, "\t{\n");
	fprintf(wrapperFile, "\t\tString constraints = \"true\";\n");
	fprintf(wrapperFile, "\t\tswitch ( OpId )\n");		
	fprintf(wrapperFile, "\t\t{\n");

	// Make constraints wrapper functions
	_case = 0;
	current_function = get_first_function();
	while (current_function != NULL) {
		generate_java_constraints_prototype(interfaceFile, current_function, "constraints", "\tabstract String");
		fprintf(interfaceFile, ";\n");
		
		generate_java_constraints_skeletons(constraintsFile, current_function);	

		generate_java_constraints_parameter_demarshalling(wrapperFile, current_function, _case, "constraints");
		current_function = current_function->next_function;
		_case++;	
	}
	fprintf(wrapperFile, "\t\t}\n");
	fprintf(wrapperFile, "\t\treturn constraints;\n");
	fprintf(wrapperFile, "\t}\n\n");

	fprintf(wrapperFile, "\tpublic double cost_function ( int OpId, String args [] )\n");   
	fprintf(wrapperFile, "\t{\n");
	fprintf(wrapperFile, "\t\tdouble cost = 0.0;\n");
	fprintf(wrapperFile, "\t\tswitch ( OpId )\n");		
	fprintf(wrapperFile, "\t\t{\n");

	// Make cost wrapper functions
	_case = 0;
	current_function = get_first_function();
	while (current_function != NULL) {
		generate_java_constraints_prototype(interfaceFile, current_function, "cost", "\tabstract double");
		fprintf(interfaceFile, ";\n");

		generate_java_constraints_parameter_demarshalling(wrapperFile, current_function, _case, "cost");
		current_function = current_function->next_function;
		_case++;	
	}
	fprintf(wrapperFile, "\t\t}\n");
	fprintf(wrapperFile, "\t\treturn cost;\n");
	fprintf(wrapperFile, "\t}\n");
	fprintf(wrapperFile, "}\n");
}
	
void generate_java_constraints_epilogue(void)
{
	fprintf(interfaceFile, "}\n");
	fprintf(constraintsFile,"}\n");
}
