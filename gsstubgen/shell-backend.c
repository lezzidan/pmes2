/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"

static const char cvs_file_id[]="$Id: shell-backend.c,v 1.9 2004/09/17 14:13:46 rsirvent Exp $";


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf


#define ARGS_OFFSET 2


static FILE **stubsFile = NULL;
static FILE *workerFile = NULL;
static FILE *includeFile = NULL;
static char includeName[PATH_MAX];



void generate_shell_prolog()
{
	function *current_function;
	char name[PATH_MAX];
	char *c;
	int i;
	
	debug_printf("Generate prolog\n");
	
	strncpy(includeName, get_filename_base(), PATH_MAX);
	strncat(includeName, ".h", PATH_MAX);
	rename_if_clash(includeName);
	includeFile = fopen(includeName, "w");
	if (includeFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", includeName);
		exit(1);
	}
	
	fprintf(includeFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(includeFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifndef _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#define _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "extern \"C\" {\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");
	
	stubsFile = (FILE **)malloc(get_function_count() * sizeof(FILE *));
	
	current_function = get_first_function();
	
	for (i = 0; i < get_function_count(); i++)
	{
		strncpy(name, get_filename_base(), PATH_MAX);
		strncat(name, "-", PATH_MAX);
		strncat(name, current_function->name, PATH_MAX);
		strncat(name, "-stub.c", PATH_MAX);
		rename_if_clash(name);
		stubsFile[i] = fopen(name, "w");
		
		if (stubsFile[i] == NULL) {
			fprintf(stderr, "Error: Could not open %s for writing.\n", name);
			exit(1);
		}
		
		fprintf(stubsFile[i], "/* This file has been autogenerated from '%s'. */\n", get_filename());
		fprintf(stubsFile[i], "/* CHANGES TO THIS FILE WILL BE LOST */\n");
		fprintf(stubsFile[i], "\n");
		fprintf(stubsFile[i], "\n");
		fprintf(stubsFile[i], "#include <stdio.h>\n");
		fprintf(stubsFile[i], "#include <stdlib.h>\n");
		fprintf(stubsFile[i], "#include <limits.h>\n");
		fprintf(stubsFile[i], "#include <string.h>\n");
		fprintf(stubsFile[i], "#include \"execute.h\"\n");
		fprintf(stubsFile[i], "#include \"%s\"\n", includeName);
		fprintf(stubsFile[i], "\n\n");
		fprintf(stubsFile[i], "int main(int argc, char **argv)\n");
		fprintf(stubsFile[i], "{\n");
		fprintf(stubsFile[i], "   char **args;\n");
		fprintf(stubsFile[i], "\n");
		
		current_function = current_function->next_function;
	}
    
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-worker.c", PATH_MAX);
	rename_if_clash(name);
	workerFile = fopen(name, "w");
	if (workerFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}
	
	fprintf(workerFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(workerFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "#include <stdio.h>\n");
	fprintf(workerFile, "#include <stdlib.h>\n");
	fprintf(workerFile, "#include <limits.h>\n");
	fprintf(workerFile, "#include <string.h>\n");
	fprintf(workerFile, "#include <GS_worker.h>\n");
	fprintf(workerFile, "#include \"%s\"\n", includeName);
	fprintf(workerFile, "\n\n");
	fprintf(workerFile, "int main(int argc, char **argv)\n");
	fprintf(workerFile, "{\n");
	fprintf(workerFile, "   enum operationCode opCod;\n");
	fprintf(workerFile, "   char command_line[500];\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   if (argc < 7)\n");
	fprintf(workerFile, "   {\n");
	fprintf(workerFile, "      printf(\"ERROR: Wrong arguments list passed to the worker\\n\");\n");
	fprintf(workerFile, "      exit(1);\n");
	fprintf(workerFile, "   }\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   opCod = (enum operationCode)atoi(argv[2]);\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   IniWorker(argc, argv);\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   switch (opCod)\n");
	fprintf(workerFile, "   {\n");
}


void generate_shell_epilogue(void)
{
	char *c;
	int i;
	
	debug_printf("Generate epilogue\n");
    
	for (i = 0; i < get_function_count(); i++)
	{
		fprintf(stubsFile[i], "}\n");
		fclose(stubsFile[i]);
	}
    
	fprintf(workerFile, "   }\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   EndWorker(gs_result, argc, argv);\n");
	fprintf(workerFile, "   return 0;\n");
	fprintf(workerFile, "}\n");
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "}\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");

	fprintf(includeFile, "#endif /* _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	
	fprintf(includeFile, " */\n");
	
	fclose(workerFile);
	fclose(includeFile);
}


static void generate_enum(FILE *outFile, function *first_function)
{
	function *func;
	int is_first = 1;
	
	fprintf(outFile, "enum operationCode {");
	
	func = first_function;
	while (func != NULL) {
		if (is_first) {
			is_first = 0;
		} else {
			fprintf(outFile, ", ");
		}
		fprintf(outFile, "%sOp", func->name);
		func = func->next_function;
	}
	
	fprintf(outFile, "};\n");
}


static void generate_execute_call(FILE *outFile, function *func)
{
	argument *arg;
	int input_files = 0;
	int input_generics = 0;
	int output_files = 0;
	int output_generics = 0;
	int inout_files = 0;
	int arg_order = 1;
	int arg_cursor;

	/* Count argument types */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->dir) {
			case in_dir:
				if (arg->type == file_dt) {
					input_files++;
				} else {
					input_generics++;
				}
				break;
			case out_dir:
				if (arg->type == file_dt) {
					output_files++;
				} else {
					fprintf(stderr, "Error: output generics not supported, function %s\n", func->name);
				}
				break;
			case inout_dir:
				if (arg->type == file_dt) {
					input_files++;
					output_files++;
					inout_files++;
				} else {
					fprintf(stderr, "Error: output generics not supported, function %s\n", func->name);
				}
				break;
			default:
				;
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "   if (argc < %i)\n",
		input_files + input_generics + output_files - inout_files + 1);
	fprintf(outFile, "   {\n");
	fprintf(outFile, "      printf(\"ERROR: Wrong arguments list passed to the stub\\n\");\n");
	fprintf(outFile, "      exit(1);\n");
	fprintf(outFile, "   }\n");
	fprintf(outFile, "\n");
	fprintf(outFile, "   args = (char **)malloc(%i*sizeof(char *));\n",
		input_files + input_generics + output_files);
	fprintf(outFile, "\n");
	
	/* Pass input files */
	arg = func->first_argument; arg_cursor = 1;
	while (arg != NULL) {
		if ((arg->dir == in_dir || arg->dir == inout_dir) && arg->type == file_dt) {
			fprintf(outFile, "   args[%i] = argv[%i];\n", arg_order - 1, arg_cursor);
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument; arg_cursor++;
	}
	
	/* Pass input generics */
	arg = func->first_argument; arg_cursor = 1;
	while (arg != NULL) {
		if (arg->dir == in_dir && arg->type != file_dt) {
			switch (arg->type) {
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "   args[%i] = argv[%i];\n", arg_order - 1, arg_cursor);
					break;
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
			}
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument; arg_cursor++;
	}
	
	/* Pass output files */
	arg = func->first_argument; arg_cursor = 1;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type == file_dt) {
			fprintf(outFile, "   args[%i] = argv[%i];\n", arg_order - 1, arg_cursor);
			arg->passing_out_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument; arg_cursor++;
	}
	
	fprintf(outFile, "   execute(%sOp, %i, %i, %i, %i, args);\n",
		func->name, input_files, input_generics, output_files, output_generics);
}


/* Note: requires passing_(in/out)_order to be set (by generate_execute_call) */
static void generate_worker_case(FILE *outFile, function *func)
{
	argument *arg;
	int is_first_arg = 1;
	int i;
	
	debug_printf("\n*** Function %s\n", func->name);
	
	fprintf(outFile, "      case %sOp:\n", func->name);
	fprintf(outFile, "         {\n");
	
	/* Make the call */
	fprintf(outFile, "            sprintf(command_line, \"./%s", func->name);
	
	for (i=0; i < func->argument_count; i++) fprintf(outFile, " %%s");
	
	fprintf(outFile, "\"");
	
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case string_dt:
				case wstring_dt:
				case file_dt:
					fprintf(outFile, ", argv[%i]", arg->passing_in_order + ARGS_OFFSET);
					break;
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		} else { /* out_dir || inout_dir */
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case string_dt:
				case wstring_dt:
					/* Error: out and inout generics not supported */
					break;
				case file_dt:
					fprintf(outFile, ", argv[%i]", arg->passing_out_order + ARGS_OFFSET);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, ");\n");
	fprintf(outFile, "            gs_result = GS_System(command_line);\n");
	fprintf(outFile, "         }\n");
	fprintf(outFile, "         break;\n");
}


void generate_shell_body(void)
{
	function *current_function;
	int i;
	
	debug_printf("Generate body\n");
	
	generate_enum(includeFile, get_first_function());
	
	current_function = get_first_function();
	
	for (i = 0; i < get_function_count(); i++)
	{
		generate_execute_call(stubsFile[i], current_function);
		generate_worker_case(workerFile, current_function);
		
		current_function = current_function->next_function;
	}
}
