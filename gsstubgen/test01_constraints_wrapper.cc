/* This file has been autogenerated from 'test01.idl'. */
/* Generator component: $Id: c-constraints-backend.c,v 1.2 2004/11/19 10:00:34 perez Exp $ */
/* CHANGES TO THIS FILE WILL BE LOST */

static const char gs_generator[]="$Id: c-constraints-backend.c,v 1.2 2004/11/19 10:00:34 perez Exp $";

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <string>
#include <classad_distribution.h>
#include <gs_base64.h>
#include "test01_constraints.h"


using namespace std;


typedef ClassAd (*constraints_wrapper) (char **_parameters, int OpId, int nparams);
typedef double (*cost_wrapper) (char **_parameters, int OpId, int nparams);


// Prototypes
ClassAd Subst_constraints_wrapper(char **_parameters, int OpId, int nparams);
double Subst_cost_wrapper(char **_parameters, int OpId, int nparams);
ClassAd Dimem_constraints_wrapper(char **_parameters, int OpId, int nparams);
double Dimem_cost_wrapper(char **_parameters, int OpId, int nparams);
ClassAd Post_constraints_wrapper(char **_parameters, int OpId, int nparams);
double Post_cost_wrapper(char **_parameters, int OpId, int nparams);


// Pointers to function tables
constraints_wrapper * constraints_functions;
cost_wrapper * cost_functions;

void initConstraints()
{
   int Ops = 3;

   // Allocate memory for function pointers
   constraints_functions = new constraints_wrapper[Ops];
   cost_functions = new cost_wrapper[Ops];

   constraints_functions[0] = &Subst_constraints_wrapper;
   cost_functions[0] = &Subst_cost_wrapper;
   constraints_functions[1] = &Dimem_constraints_wrapper;
   cost_functions[1] = &Dimem_cost_wrapper;
   constraints_functions[2] = &Post_constraints_wrapper;
   cost_functions[2] = &Post_cost_wrapper;
}


void finConstraints()
{
   // Free memory allocated for function arrays
   delete constraints_functions;
   delete cost_functions;
}


ClassAd Subst_constraints_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_referenceCFG;
   char *buff_seed;

   // Real parameters
   char *referenceCFG;
   double seed;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_referenceCFG = *(_argp++);
   buff_seed = *(_argp++);

   //Datatype conversion
   referenceCFG = buff_referenceCFG;
   seed = strtod(buff_seed, NULL);

   
//Description function parameters
   int numCPUs;
   char *jobType;
   Subst_description( &numCPUs, &jobType , referenceCFG, seed);
   string _constraints = Subst_constraints(referenceCFG, seed);

   ClassAd _ad;
   ClassAdParser _parser;
   _ad.Insert("Requirements", _parser.ParseExpression(_constraints));
   _ad.InsertAttr("numCPUs", numCPUs);
   _ad.InsertAttr("jobType", jobType);

   // Free buffers

   return _ad;
}


double Subst_cost_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_referenceCFG;
   char *buff_seed;

   // Real parameters
   char *referenceCFG;
   double seed;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_referenceCFG = *(_argp++);
   buff_seed = *(_argp++);

   //Datatype conversion
   referenceCFG = buff_referenceCFG;
   seed = strtod(buff_seed, NULL);

   double _cost = Subst_cost(referenceCFG, seed);

   // Free buffers

   return _cost;
}


ClassAd Dimem_constraints_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_newCFG;
   char *buff_traceFile;

   // Real parameters
   char *newCFG;
   char *traceFile;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_newCFG = *(_argp++);
   buff_traceFile = *(_argp++);

   //Datatype conversion
   newCFG = buff_newCFG;
   traceFile = buff_traceFile;

   
//Description function parameters
   int numCPUs;
   char *jobType;
   Dimem_description( &numCPUs, &jobType , newCFG, traceFile);
   string _constraints = Dimem_constraints(newCFG, traceFile);

   ClassAd _ad;
   ClassAdParser _parser;
   _ad.Insert("Requirements", _parser.ParseExpression(_constraints));
   _ad.InsertAttr("numCPUs", numCPUs);
   _ad.InsertAttr("jobType", jobType);

   // Free buffers

   return _ad;
}


double Dimem_cost_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_newCFG;
   char *buff_traceFile;

   // Real parameters
   char *newCFG;
   char *traceFile;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_newCFG = *(_argp++);
   buff_traceFile = *(_argp++);

   //Datatype conversion
   newCFG = buff_newCFG;
   traceFile = buff_traceFile;

   double _cost = Dimem_cost(newCFG, traceFile);

   // Free buffers

   return _cost;
}


ClassAd Post_constraints_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_newCFG;
   char *buff_DimemasOUT;
   char *buff_FinalOUT;

   // Real parameters
   char *newCFG;
   char *DimemasOUT;
   char *FinalOUT;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_newCFG = *(_argp++);
   buff_DimemasOUT = *(_argp++);
   buff_FinalOUT = *(_argp++);

   //Datatype conversion
   newCFG = buff_newCFG;
   DimemasOUT = buff_DimemasOUT;
   FinalOUT = buff_FinalOUT;

   
//Description function parameters
   int numCPUs;
   char *jobType;
   Post_description( &numCPUs, &jobType , newCFG, DimemasOUT, FinalOUT);
   string _constraints = Post_constraints(newCFG, DimemasOUT, FinalOUT);

   ClassAd _ad;
   ClassAdParser _parser;
   _ad.Insert("Requirements", _parser.ParseExpression(_constraints));
   _ad.InsertAttr("numCPUs", numCPUs);
   _ad.InsertAttr("jobType", jobType);

   // Free buffers

   return _ad;
}


double Post_cost_wrapper(char **_parameters, int OpId, int nparams) {
   char **_argp;

   // Generic buffers
   char *buff_newCFG;
   char *buff_DimemasOUT;
   char *buff_FinalOUT;

   // Real parameters
   char *newCFG;
   char *DimemasOUT;
   char *FinalOUT;

   // Allocate buffers

   // Read parameters
   _argp = _parameters;
   buff_newCFG = *(_argp++);
   buff_DimemasOUT = *(_argp++);
   buff_FinalOUT = *(_argp++);

   //Datatype conversion
   newCFG = buff_newCFG;
   DimemasOUT = buff_DimemasOUT;
   FinalOUT = buff_FinalOUT;

   double _cost = Post_cost(newCFG, DimemasOUT, FinalOUT);

   // Free buffers

   return _cost;
}


