/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"

static const char cvs_file_id[]="$Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $";


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf


#define ARGS_OFFSET 6


static FILE *stubsFile = NULL;
static FILE *workerFile = NULL;
static FILE *includeFile = NULL;
static FILE *const_file = NULL;
static char includeName[PATH_MAX];

static char *c_types[] = { "void", "char", "char", "int", "void *", "short",
	"long", "long long", "int", "float", "double", "file", "char *", "char *", "error" };
static char *c_out_types[] = { "error", "char *", "char *", "int *", "void *",
	"short *", "long *" , "long long *" , "int *", "float *", "double *", "file", "char *",
	"char *", "error" };



void generate_prolog()
{
	char name[PATH_MAX];
	char *c;
	
	debug_printf("Generate prolog\n");
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-stubs.cc", PATH_MAX);
	rename_if_clash(name);
	stubsFile = fopen(name, "w");
	if (stubsFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-worker.c", PATH_MAX);
	rename_if_clash(name);
	workerFile = fopen(name, "w");
	if (workerFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	strncpy(includeName, get_filename_base(), PATH_MAX);
	strncat(includeName, ".h", PATH_MAX);
	rename_if_clash(includeName);
	includeFile = fopen(includeName, "w");
	if (includeFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", includeName);
		exit(1);
	}
	
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-constraints", PATH_MAX);
	rename_if_clash(name);
	const_file = fopen(name, "w");
	if (const_file == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}
	
	fprintf(stubsFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(stubsFile, "/* Generator component: $Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $ */\n");
	fprintf(stubsFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "static const char gs_generator[]=\"$Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $\";\n");
	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "#include <stdio.h>\n");
	fprintf(stubsFile, "#include <stdlib.h>\n");
	fprintf(stubsFile, "#include <limits.h>\n");
	fprintf(stubsFile, "#include <string.h>\n");
	//fprintf(stubsFile, "#include <gs_base64.h>\n");
	//fprintf(stubsFile, "#include <GS_master.h>\n");
	fprintf(stubsFile, "#include <jni.h>\n");
	fprintf(stubsFile, "#include \"%s\"\n", includeName);
	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "\n");
	
	fprintf(workerFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(workerFile, "/* Generator component: $Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $ */\n");
	fprintf(workerFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "static const char gs_generator[]=\"$Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $\";\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "#include <stdio.h>\n");
	fprintf(workerFile, "#include <stdlib.h>\n");
	fprintf(workerFile, "#include <limits.h>\n");
	fprintf(workerFile, "#include <string.h>\n");
	fprintf(workerFile, "#include <unistd.h>\n");
	fprintf(workerFile, "#include <gs_base64.h>\n");
//	fprintf(workerFile, "#include <GS_worker.h>\n");
	fprintf(workerFile, "#include \"%s\"\n", includeName);
	fprintf(workerFile, "\n\n");
	fprintf(workerFile, "int main(int argc, char **argv)\n");
	fprintf(workerFile, "{\n");
	fprintf(workerFile, "   enum operationCode opCod;\n");
	fprintf(workerFile, "\n");
#if 0
	fprintf(workerFile, "   if(argc < 7)\n");
	fprintf(workerFile, "   {\n");
	fprintf(workerFile, "      printf(\"ERROR: Wrong arguments list passed to the worker\\n\");\n");
	fprintf(workerFile, "      exit(1);\n");
	fprintf(workerFile, "   }\n");
#endif	
	fprintf(workerFile, "   opCod = (enum operationCode)atoi(argv[4]);\n");
	fprintf(workerFile, "\n");
	//fprintf(workerFile, "   IniWorker(argc, argv);\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   switch(opCod)\n");
	fprintf(workerFile, "   {\n");
	
	fprintf(includeFile, "/* This file must be #included in the actual implementation file. */\n");
	fprintf(includeFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(includeFile, "/* Generator component: $Id: c-backend.c,v 1.11 2004/11/19 10:00:34 perez Exp $ */\n");
	fprintf(includeFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifndef _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	fprintf(includeFile, "\n");
	
	fprintf(includeFile, "#define _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	fprintf(includeFile, "\n");
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "extern \"C\" {\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "/* The actual functions must use this variable to return their error codes */\n");
	fprintf(includeFile, "extern int gs_result;\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "typedef char* file;\n");
	fprintf(includeFile, "\n");
	
}


void generate_epilogue(void)
{
	char *c;
	
	debug_printf("Generate epilogue\n");

#if 0	
	fprintf(stubsFile, "int getFunctionCount()\n");
	fprintf(stubsFile, "{\n");
	fprintf(stubsFile, "    return %i;\n", get_function_count());
	fprintf(stubsFile, "}\n");
	fprintf(stubsFile, "\n");
#endif
	
	fprintf(workerFile, "   }\n");
	fprintf(workerFile, "\n");
//	fprintf(workerFile, "   EndWorker(gs_result, argc, argv);\n");
	fprintf(workerFile, "   return 0;\n");
	fprintf(workerFile, "}\n");
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "}\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");

	fprintf(includeFile, "#endif /* _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	
	fprintf(includeFile, " */\n");
	
	fclose(stubsFile);
	fclose(workerFile);
	fclose(includeFile);
	fclose(const_file);

}

static void generate_constraints(function *func)
{
	constraint *constr;
	int is_first = 1;
	
	printf("Generating constraints\n");
	
	constr=func->first_constraint;
	while(constr!=NULL)
	{
		if(is_first)
			is_first = 0;
		else
			fprintf(const_file, ", ");
		
		fprintf(const_file, "%s", constr->name);
		constr = constr->next_constraint;
	}
	fprintf(const_file, "\n");

}

static void generate_enum(FILE *outFile, function *first_function)
{
	function *func;
	int is_first = 1;
	
	fprintf(outFile, "enum operationCode {");
	
	func = first_function;
	while (func != NULL) {
		if (is_first) {
			is_first = 0;
		} else {
			fprintf(outFile, ", ");
		}
		fprintf(outFile, "%sOp", func->name);
		func = func->next_function;
	}
	
	fprintf(outFile, "};\n");
	
	fprintf(outFile ,"\n");
}


static void generate_prototype(FILE *outFile, function *current_function)
{
	argument *current_argument;

	fprintf(outFile, "%s %s(",
		c_types[current_function->return_type],
		current_function->name);
	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		if (current_argument->dir == in_dir) {
			fprintf(outFile, "%s ", c_types[current_argument->type]);
		} else {
			fprintf(outFile, "%s ", c_out_types[current_argument->type]);
		}
		fprintf(outFile, "%s", current_argument->name);
		current_argument = current_argument->next_argument;
		if (current_argument != NULL) {
			fprintf(outFile, ", ");
		}
	}
	fprintf(outFile, ")");
}


static void generate_parameter_buffers(FILE *outFile, function *func)
{
	argument *arg;
	int ch, bo, sh, in, lo, db, fi, fl, st; 

	ch = bo = sh = in = lo = db = fi = fl = st = 0;
	
	fprintf(outFile, "   /* JNI environment */\n");
	fprintf(outFile, "   extern JNIEnv *env;\n");
	fprintf(outFile, "   extern jobject jobjIT;\n\n");
	fprintf(outFile, "   extern jclass clsITimpl; /* integratedtoolkit.api.impl.IntegratedToolkitImpl class */ \n\n");
	
	fprintf(outFile, "   jmethodID midExecute = NULL; /* ID of the executeTask method in the integratedtoolkit.api.impl.IntegratedToolkitImpl class  */ \n");
	fprintf(outFile, "   jclass clsObject = NULL; /*  java.lang.Object class */\n");
	fprintf(outFile, "   jmethodID midObjCon = NULL; /* ID of the java.lang.Object class constructor method */ \n\n");
	
	fprintf(outFile, "   jclass clsParType = NULL; /* integratedtoolkit.api.ITExecution$ParamType class */ \n");
	fprintf(outFile, "   clsParType = env->FindClass(\"integratedtoolkit/api/ITExecution$ParamType\"); \n");
	fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "   	env->ExceptionDescribe(); \n");
	fprintf(outFile, "   	exit(0); \n\n");
	fprintf(outFile, "   } \n");
	fprintf(outFile, "   jmethodID midParTypeCon = NULL; /* ID of the integratedtoolkit.api.ITExecution$ParamType class constructor method */ \n");
	fprintf(outFile, "   midParTypeCon = env->GetStaticMethodID(clsParType, \"valueOf\", \"(Ljava/lang/String;)Lintegratedtoolkit/api/ITExecution$ParamType;\"); \n");
	fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "   	env->ExceptionDescribe(); \n");
	fprintf(outFile, "   	exit(0); \n");
	fprintf(outFile, "   } \n\n");
	

	
	fprintf(outFile, "   jclass clsParDir = NULL; /* integratedtoolkit.api.ITExecution$ParamDirection class */ \n");
	fprintf(outFile, "   jmethodID midParDirCon = NULL; /* ID of the integratedtoolkit.api.ITExecution$ParamDirection class constructor method */ \n");
	fprintf(outFile, "   jobject jobjParDirIN  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamDirection class */ \n");
	fprintf(outFile, "   jobject jobjParDirINOUT  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamDirection class */ \n");
	fprintf(outFile, "   jobject jobjParDirOUT  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamDirection class */ \n\n");
	
	fprintf(outFile, "   clsParDir = env->FindClass(\"integratedtoolkit/api/ITExecution$ParamDirection\"); \n");
	fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "   	env->ExceptionDescribe(); \n");
	fprintf(outFile, "   	exit(0); \n\n");
	fprintf(outFile, "   } \n\n");
	
	fprintf(outFile, "   if(clsParDir != NULL) \n");
	fprintf(outFile, "   { \n");
	fprintf(outFile, "   	midParDirCon = env->GetStaticMethodID(clsParDir, \"valueOf\", \"(Ljava/lang/String;)Lintegratedtoolkit/api/ITExecution$ParamDirection;\"); \n");
	fprintf(outFile, "   	if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "   		env->ExceptionDescribe(); \n");
	fprintf(outFile, "   		exit(0); \n");
	fprintf(outFile, "   	} \n");
	fprintf(outFile, "   	else {\n");
	fprintf(outFile, "			jobjParDirIN =  env->CallStaticObjectMethod(clsParDir, midParDirCon, env->NewStringUTF(\"IN\")); \n");
	fprintf(outFile, "			if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "				env->ExceptionDescribe(); \n");
	fprintf(outFile, "				exit(0); \n");
	fprintf(outFile, "			} \n");
	fprintf(outFile, "			jobjParDirINOUT = env->CallStaticObjectMethod(clsParDir, midParDirCon, env->NewStringUTF(\"INOUT\")); \n");
	fprintf(outFile, "			if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "				env->ExceptionDescribe(); \n");
	fprintf(outFile, "				exit(0); \n");
	fprintf(outFile, "			} \n");
	fprintf(outFile, "			jobjParDirOUT =  env->CallStaticObjectMethod(clsParDir, midParDirCon, env->NewStringUTF(\"OUT\")); \n");
	fprintf(outFile, "			if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "				env->ExceptionDescribe(); \n");
	fprintf(outFile, "				exit(0); \n");
	fprintf(outFile, "			} \n");	
	fprintf(outFile, "		} \n");
	fprintf(outFile, "   } \n\n");
	
	fprintf(outFile, "   jobjectArray jobjOBJArr = NULL; /*  array of Objects to be passed to executeTask */\n");
	
	fprintf(outFile, "   if(clsITimpl != NULL) {\n");
	fprintf(outFile, "   	midExecute = env->GetMethodID(clsITimpl, \"executeTask\", \"(Ljava/lang/String;Ljava/lang/String;I[Ljava/lang/Object;)V\");\n");
	fprintf(outFile, "   	if (env->ExceptionOccurred()) {\n");
	fprintf(outFile, "   		env->ExceptionDescribe();\n");
	fprintf(outFile, "   		exit(0);\n");
	fprintf(outFile, "   	}\n");
	fprintf(outFile, "	 }\n");
	fprintf(outFile, "   clsObject = env->FindClass(\"java/lang/Object\");\n");
	fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
	fprintf(outFile, "   		env->ExceptionDescribe();\n");
	fprintf(outFile, "   		exit(0);\n");
	fprintf(outFile, "   }\n");
	fprintf(outFile, "   if(clsObject != NULL)\n");
	fprintf(outFile, "   {\n");				
	fprintf(outFile, "   	midObjCon = env->GetMethodID(clsObject, \"<init>\", \"()V\");\n");
	fprintf(outFile, "   	if (env->ExceptionOccurred()) {\n");
	fprintf(outFile, "   			env->ExceptionDescribe();\n");
	fprintf(outFile, "   			exit(0);\n");
	fprintf(outFile, "		}\n");
	fprintf(outFile, "	 }\n");
				
	fprintf(outFile, "   jobjOBJArr=(jobjectArray)env->NewObjectArray(%d, clsObject, env->NewObject(clsObject,midObjCon));\n", func->argument_count*3);
				
	fprintf(outFile, "   /* Marshalling buffers */\n");

	/* Declare buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
				if (ch == 0)
				{	
				fprintf(outFile, "   jclass clsCharacter = NULL; /*  java.lang.Character class */\n");
				fprintf(outFile, "   jmethodID midCharCon = NULL; /* ID of the java.lang.Character class constructor method */ \n\n");
				fprintf(outFile, "   clsCharacter = env->FindClass(\"java/lang/Character\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midCharCon = env->GetMethodID(clsCharacter, \"<init>\", \"(C)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				
				fprintf(outFile, "   jobject jobjParTypeChar  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeChar = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"CHAR_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				ch = 1;
				}
				
				break;
			case boolean_dt:
				if (bo == 0)
				{	
				fprintf(outFile, "   jclass clsBoolean = NULL; /*  java.lang.Boolean class */\n");
				fprintf(outFile, "   jmethodID midBoolCon = NULL; /* ID of the java.lang.clsBoolean class constructor method */ \n\n");
				fprintf(outFile, "   clsBoolean = env->FindClass(\"java/lang/Boolean\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   midBoolCon = env->GetMethodID(clsBoolean, \"<init>\", \"(Z)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				fprintf(outFile, "   jobject jobjParTypeBool  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeBool = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"BOOLEAN_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				bo = 1;
				}	
				break;				
			case short_dt:
				if(sh == 0)
				{	
				fprintf(outFile, "   jclass clsShort = NULL; /*  java.lang.Short class */\n");
				fprintf(outFile, "   jmethodID midShortCon = NULL; /* ID of the java.lang.Short class constructor method */ \n\n");
				fprintf(outFile, "   clsShort = env->FindClass(\"java/lang/Short\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midShortCon = env->GetMethodID(clsShort, \"<init>\", \"(S)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   jobject jobjParTypeShort  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeShort = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"SHORT_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				sh = 1;
				}
				break;								
			case int_dt:
				if(in == 0)
				{
				fprintf(outFile, "   jclass clsInteger = NULL; /*  java.lang.Integer class */\n");
				fprintf(outFile, "   jmethodID midIntCon = NULL; /* ID of the java.lang.Integer class constructor method */ \n\n");
				fprintf(outFile, "   clsInteger = env->FindClass(\"java/lang/Integer\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midIntCon = env->GetMethodID(clsInteger, \"<init>\", \"(I)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   jobject jobjParTypeInt  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeInt = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"INT_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				in = 1;
				}
				break;												
			case long_dt:
				if(lo == 0)
				{
				fprintf(outFile, "   jclass clsLong = NULL; /*  java.lang.Long class */\n");
				fprintf(outFile, "   jmethodID midLongCon = NULL; /* ID of the java.lang.Long class constructor method */ \n\n");
				fprintf(outFile, "   clsLong = env->FindClass(\"java/lang/Long\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midLongCon = env->GetMethodID(clsLong, \"<init>\", \"(J)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   jobject jobjParTypeLong  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeLong = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"LONG_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				lo = 1;
				}
				break;																
			case longlong_dt:
			case float_dt:
				if (fl == 0)
				{
				fprintf(outFile, "   jclass clsFloat = NULL; /*  java.lang.Float class */\n");
				fprintf(outFile, "   jmethodID midFloatCon = NULL; /* ID of the java.lang.Float class constructor method */ \n\n");
				fprintf(outFile, "   clsFloat = env->FindClass(\"java/lang/Float\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midFloatCon = env->GetMethodID(clsFloat, \"<init>\", \"(F)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   jobject jobjParTypeFloat  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeFloat = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"FLOAT_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				fl = 1;
				}
				break;																				
			case double_dt:
				if (db == 0)
				{
				fprintf(outFile, "   jclass clsDouble = NULL; /*  java.lang.Double class */\n");
				fprintf(outFile, "   jmethodID midDoubleCon = NULL; /* ID of the java.lang.Double class constructor method */ \n\n");
				fprintf(outFile, "   clsDouble = env->FindClass(\"java/lang/Double\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n");
				
				fprintf(outFile, "   midDoubleCon = env->GetMethodID(clsDouble, \"<init>\", \"(D)V\");\n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) {\n");
				fprintf(outFile, "   	env->ExceptionDescribe();\n");
				fprintf(outFile, "   	exit(0);\n");
				fprintf(outFile, "   }\n\n");
				
				fprintf(outFile, "   jobject jobjParTypeDouble  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeDouble = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"DOUBLE_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				db = 1;
				}
				break;					
			case file_dt:
				if (fi == 0)
				{
				fprintf(outFile, "   jobject jobjParTypeFile  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeFile = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"FILE_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				fi =1;
				}
				break;
			case string_dt:
			case wstring_dt:
				if (st == 0)
				{
				fprintf(outFile, "   jobject jobjParTypeString  = NULL; /* Instance of the integratedtoolkit.api.ITExecution$ParamType class */ \n");
				fprintf(outFile, "   jobjParTypeString = env->CallStaticObjectMethod(clsParType, midParTypeCon, env->NewStringUTF(\"STRING_T\")); \n");
				fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
				fprintf(outFile, "   	env->ExceptionDescribe(); \n");
				fprintf(outFile, "   	exit(0); \n");
				fprintf(outFile, "   } \n\n");
				
				st = 1;
				}	
				break;
			case void_dt:
			case any_dt:
			case null_dt:
			default:
				fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
				break;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}

static void allocate_parameter_buffers(FILE *outFile, function *func)
{
	argument *arg;

	fprintf(outFile, "   /* Allocate buffers */\n");

	/* Allocate buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:				
				break;
			case boolean_dt:
				break;
			case short_dt:
			case int_dt:
			case long_dt:
			case longlong_dt:
			case float_dt:
			case double_dt:
				break;
			case file_dt:
				/* No buffer needed */
				break;
			case string_dt:
			case wstring_dt:
				break;
			case void_dt:
			case any_dt:
			case null_dt:
			default:
				break;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}



static void deallocate_parameter_buffers(FILE *outFile, function *func)
{
	argument *arg;
	fprintf(outFile, "   /* Deallocate buffers */\n");

	/* Deallocate buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
				break;
			case boolean_dt:
				break;
			case short_dt:
				break;
			case int_dt:
				break;
			case long_dt:
				break;
			case longlong_dt:
				break;
			case float_dt:
				break;
			case double_dt:
				break;
			case file_dt:
				/* No buffer needed */
				break;
			case string_dt:
			case wstring_dt:
				break;
			case void_dt:
			case any_dt:
			case null_dt:
			default:
				fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
				break;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}



static void generate_parameter_marshalling(FILE *outFile, function *func)
{
	argument *arg;
	int j = 0;
	int i = 0;
	fprintf(outFile, "\n\n   /* Parameter marshalling */\n");

	/* Convert input parameters */
	arg = func->first_argument;
	while (arg != NULL) {
		i = j*3;
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsCharacter, midCharCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeChar);\n", i+1); 
					break;
				case boolean_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsBoolean, midBoolCon, %s));\n", i, arg->name);
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeBool);\n", i+1); 
					break;
				case short_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsShort, midShortCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeShort);\n", i+1); 
					break;
				case int_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsInteger, midIntCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeInt);\n", i+1); 
					break;
				case long_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsLong, midLongCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeLong);\n", i+1); 
					break;
				case longlong_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsLong, midLongCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeLong);\n", i+1); 
					break;
				case float_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsFloat, midFloatCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeFloat);\n", i+1); 
					break;
				case double_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewObject(clsDouble, midDoubleCon, %s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeDouble);\n", i+1); 
					break;
				case file_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewStringUTF(%s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeFile);\n", i+1); 
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewStringUTF(%s));\n", i, arg->name); 
					fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeString);\n", i+1); 
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParDirIN);\n", i+2); 
		}
	else if (arg->dir == inout_dir)
		if(arg->type == file_dt)
		{
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewStringUTF(%s));\n", i, arg->name); 
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeFile);\n", i+1); 
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParDirINOUT);\n", i+2); 
		}
		else
			fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
	else if(arg->dir == out_dir)
		if(arg->type == file_dt)
		{
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, env->NewStringUTF(%s));\n", i, arg->name); 
			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParTypeFile);\n", i+1); 

			fprintf(outFile, "   env->SetObjectArrayElement(jobjOBJArr, %d, jobjParDirOUT);\n", i+2); 
		}
			else
			fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
	
		arg = arg->next_argument;
		j++;
	}
	
	fprintf(outFile, "\n");
}	


static void generate_parameter_demarshalling(FILE *outFile, function *func)
{
	argument *arg;
	int need_demarshalling = 0;
	
	/* Check if we need to demarshall and thus the infamous barrier */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					need_demarshalling = 1;
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					need_demarshalling = 1;
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		}
		arg = arg->next_argument;
	}
	
	if (!need_demarshalling) return;
	
		
	fprintf(outFile, "   /* Parameter demarshalling */\n");

	/* Convert output parameters */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "   *%s = buff_%s[0];\n", arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "   *%s = atoi(buff_%s);\n", arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "   *%s = atoi(buff_%s);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "   *%s = atol(buff_%s);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "   *%s = atoll(buff_%s);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "   *%s = atoi(buff_%s);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "   *%s = strtod(buff_%s, NULL);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "   *%s = strtod(buff_%s, NULL);\n", arg->name, arg->name);
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "   gs_b64_pton(base64buff_%s, %s, atoi(getenv(\"GS_GENLENGTH\"))+1);\n", arg->name, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}	


/* Note: sets passing_order in each argument */
static void generate_execute_call(FILE *outFile, function *func)
{
	argument *arg;
	char *class_name = strdup("NULL");
	char *method_name = NULL;
	
	int input_files = 0;
	int input_generics = 0;
	int output_files = 0;
	int output_generics = 0;
	int arg_order = 1;

	/* Count argument types */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->dir) {
			case in_dir:
				if (arg->type == file_dt) {
					input_files++;
				} else {
					input_generics++;
				}
				break;
			case out_dir:
				if (arg->type == file_dt) {
					output_files++;
				} else {
					output_generics++;
				}
				break;
			case inout_dir:
				if (arg->type == file_dt) {
					input_files++;
					output_files++;
				} else {
					input_generics++;
					output_generics++;
				}
				break;
			default:
				;
		}
		arg = arg->next_argument;
	}
//	fprintf(outFile, "   Execute(%sOp, %i, %i, %i, %i",
//		func->name, input_files, input_generics, output_files, output_generics);
	
	/* Pass input files */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == in_dir || arg->dir == inout_dir) && arg->type == file_dt) {
			//fprintf(outFile, ", %s", arg->name);
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass input generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == in_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				//	fprintf(outFile, ", %s", arg->name);
					break; 
				case string_dt:
				case wstring_dt:
				//	fprintf(outFile, ", %s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass output files */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type == file_dt) {
		//	fprintf(outFile, ", %s", arg->name);
			arg->passing_out_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass output generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					//fprintf(outFile, ", buff_%s", arg->name);
					break; 
				case string_dt:
				case wstring_dt:
				//	fprintf(outFile, ", base64buff_%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
			arg->passing_out_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "    char *method_num = NULL;\n");
	
	method_name = (char *)malloc(sizeof(char)*strlen(func->name)+3);
	sprintf(method_name, "%sOp", func->name);
//	fprintf(outFile, "    opCod = (enum operationCode)atoi(%s);\n", method_name);
	fprintf(outFile, "    method_num = (char *)malloc(sizeof(char)*2);\n");
	fprintf(outFile, "    sprintf(method_num, \"%%d\", %s);\n", method_name);

	fprintf(outFile, "    env->CallVoidMethod(jobjIT, midExecute, %s, env->NewStringUTF(method_num), %d, jobjOBJArr);\n", class_name, func->argument_count);
	fprintf(outFile, "   if (env->ExceptionOccurred()) { \n");
	fprintf(outFile, "   	env->ExceptionDescribe(); \n");
	fprintf(outFile, "   	exit(0); \n");
	fprintf(outFile, "   } \n");
	
	fprintf(outFile, "\n");

	fprintf(outFile, "free(method_num);\n");
}


/* Note: requires passing_(in/out)_order to be set (by generate_execute_call) */
static void generate_worker_case(FILE *outFile, function *func)
{
	argument *arg;
	int is_first_arg = 1;
	int arg_off = 0;
	int arg_val_off = 0;
	
	debug_printf("\n*** Function %s\n", func->name);
	
	
	fprintf(outFile, "      case %sOp:\n", func->name);
	fprintf(outFile, "         {\n");

	/* Declare out generic buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "            char *buff_%s;\n", arg->name);
					break; 
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "            char *base64buff_%s;\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	/* Declare (demarshalled) generics */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
				fprintf(outFile, "            char %s;\n", arg->name);
				break;
			case boolean_dt:
				fprintf(outFile, "            int %s;\n", arg->name);
				break;
			case short_dt:
				fprintf(outFile, "            short %s;\n", arg->name);
				break;
			case long_dt:
				fprintf(outFile, "            long %s;\n", arg->name);
				break;
			case longlong_dt:
				fprintf(outFile, "            long long %s;\n", arg->name);
                break;
			case int_dt:
				fprintf(outFile, "            int %s;\n", arg->name);
				break;
			case float_dt:
				fprintf(outFile, "            float %s;\n", arg->name);
				break;
			case double_dt:
				fprintf(outFile, "            double %s;\n", arg->name);
				break;
			case file_dt:
				break;
			case string_dt:
			case wstring_dt:
				fprintf(outFile, "            char *%s;\n", arg->name);
				break;
			case void_dt:
		case any_dt:
			case null_dt:
			default:
				;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
	

	/* Allocate generic buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "            buff_%s = (char *)malloc(256*sizeof(char));\n", arg->name);
					break; 
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "            base64buff_%s = (char *)malloc(256*sizeof(char));\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "\n");


	/* Allocate (demarshalled) generics */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
			case boolean_dt:
			case short_dt:
			case long_dt:
			case longlong_dt:
			case int_dt:
			case float_dt:
			case double_dt:
			case file_dt:
				break;
			case string_dt:
			case wstring_dt:
				
				//fprintf(outFile, "            %s = (char *)malloc(256*sizeof(char));\n", arg->name);
				break;
			case void_dt:
		case any_dt:
			case null_dt:
			default:
				;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
		


	/* Fill in and inout generics */
	arg = func->first_argument;
	arg_val_off = ARGS_OFFSET-1; //Arguments initial offset
	
	while (arg != NULL) {
		
		if (arg->dir == in_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					
					arg_val_off+=2;
					fprintf(outFile, "            %s = argv[%i][0];\n", arg->name, arg_val_off);	
					
					break;
				case boolean_dt:

					arg_val_off+=2;
                                        fprintf(outFile, "            %s = atoi(argv[%i]);\n", arg->name, arg_val_off);
	
					break;
				case short_dt:

					arg_val_off+=2;
                                        fprintf(outFile, "            %s = atoi(argv[%i]);\n", arg->name, arg_val_off);

					break;
				case long_dt:
				
					arg_val_off+=2;
                                        fprintf(outFile, "            %s = atol(argv[%i]);\n", arg->name, arg_val_off);
					
					break;
				case longlong_dt:
	                    			
					arg_val_off+=2;
					fprintf(outFile, "            %s = atoll(argv[%i]);\n", arg->name,arg_val_off);
					
					break;
				case int_dt:
					
					arg_val_off+=2;
					fprintf(outFile, "            %s = atoi(argv[%i]);\n", arg->name, arg_val_off);

					break;
				case float_dt:
						
					arg_val_off+=2;
					fprintf(outFile, "            %s = strtod(argv[%i], NULL);\n", arg->name, arg_val_off);
					
					break;
				case double_dt:

					arg_val_off+=2;
					fprintf(outFile, "            %s = strtod(argv[%i], NULL);\n", arg->name, arg_val_off);

					break;
				case file_dt:
					arg_val_off+=2;

					break;
				case string_dt:
				case wstring_dt:

					/*
					//START DEBUG CODE
					fprintf(outFile,"               //======== DEBUG ======== \n");
                                        fprintf(outFile,"		//FUN NAME %s \n",func->name);
					fprintf(outFile,"               //CALCULATING %s \n",arg->name);
                                        fprintf(outFile,"               //ARGS_OFFSET= %i\n",ARGS_OFFSET);
                                        fprintf(outFile,"               //arg_val_off = %i\n",arg_val_off);
                                        fprintf(outFile,"               //arg_off = %i\n",arg_off);
                                        fprintf(outFile,"               //passing_in_order = %i\n",arg->passing_in_order);
					fprintf(outFile,"               //arg_num = %i\n",arg_num);
					//END OF DEBUG CODE
					*/
					
					 //fprintf(outFile,"            %s = strdup(argv[%i]);\n", arg->name,ARGS_OFFSET+(n_elem_arg*(arg_num))+arg_val_off);
	
					arg_val_off+=3;
					fprintf(outFile,"            %s = strdup(argv[%i]);\n", arg->name, arg_val_off);

					break;

				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
				
		}
		
		arg = arg->next_argument;
	}

	fprintf(outFile, "            chdir(argv[1]);\n");
	
	/* Make the call */
	fprintf(outFile, "            %s(", func->name);
	is_first_arg = 1;
	arg_off = -1;
	arg = func->first_argument;

	while (arg != NULL) {
		if (is_first_arg) {
			is_first_arg = 0;
		} else {
		//	arg_off = 3;
			fprintf(outFile, ", ");
		}
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s", arg->name);
					arg_off+=3;
					break;
				case file_dt:
					arg_off+=2;
					fprintf(outFile, "argv[%i]", arg_off + ARGS_OFFSET);
					break;
				case string_dt:
				case wstring_dt:
					arg_off+=3;
					fprintf(outFile, "%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		} else { /* out_dir || inout_dir */
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "&%s", arg->name);
					arg_off+=3;
					break;
				case file_dt:
					arg_off+=2;
					fprintf(outFile, "argv[%i]", arg_off + ARGS_OFFSET);
					break;
				case string_dt:
				case wstring_dt:
					arg_off += 3;
					fprintf(outFile, "%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, ");\n");
	
	fprintf(outFile, "\n");
	
	/* Marshall out/inout generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == inout_dir || arg->dir == out_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "            buff_%s[0] = %s;\n", arg->name, arg->name);
					fprintf(outFile, "            buff_%s[1] = 0;\n", arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%i\", %s);\n", arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%i\", %s);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%li\", %s);\n", arg->name, arg->name);
					break;
				case longlong_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%lli\", %s);\n", arg->name, arg->name);
					break;
				case int_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%i\", %s);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%.10g\", %s);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "            sprintf(buff_%s, \"%%.20g\", %s);\n", arg->name, arg->name);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
				/*	fprintf(outFile, "            gs_b64_ntop(%s, strlen(%s)+1, base64buff_%s, 256);\n",
						arg->name, arg->name, arg->name);
				 */
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
				
		}
		arg = arg->next_argument;
	}
#if 0
	/* Set generics in order */
	for (arg_number = 1; arg_number <= func->exec_arg_count; arg_number++)
	{
		arg = func->first_argument;
		while (arg != NULL) {
			if (arg->passing_out_order == arg_number &&
				(arg->dir == inout_dir || arg->dir == out_dir)) {
				switch (arg->type) {
					case char_dt:
					case wchar_dt:
					case boolean_dt:
					case short_dt:
					case long_dt:
					case longlong_dt:
					case int_dt:
					case float_dt:
					case double_dt:
						fprintf(outFile, "            leaveDestGen(buff_%s);\n", arg->name);
						break;
					case file_dt:
						break;
					case string_dt:
					case wstring_dt:
						fprintf(outFile, "            leaveDestGen(base64buff_%s);\n", arg->name);
						break;
					case void_dt:
					case any_dt:
					case null_dt:
					default:
						;
				}
			}
			arg = arg->next_argument;
		}
	}

#endif

	/* Deallocate generic buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "            free(buff_%s);\n", arg->name);
					break; 
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "            free(base64buff_%s);\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "\n");


	/* Deallocate (demarshalled) generics */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
			case boolean_dt:
			case short_dt:
			case long_dt:
			case longlong_dt:
			case int_dt:
			case float_dt:
			case double_dt:
			case file_dt:
				break;
			case string_dt:
			case wstring_dt:
				fprintf(outFile, "            free(%s);\n", arg->name);
				break;
			case void_dt:
		case any_dt:
			case null_dt:
			default:
				;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
		



	
	fprintf(outFile, "         }\n");
	
	fprintf(outFile, "         break;\n");
	
}	
			

void generate_body(void)
{
	function *current_function;
	debug_printf("Generate body\n");
	
	generate_enum(includeFile, get_first_function());
	fprintf(includeFile, "/* Functions to be implemented. We sugest that you create a file */\n");
	fprintf(includeFile, "/* with name '%s-functions.c' and implement them there. */\n", get_filename_base());

	current_function = get_first_function();
	while (current_function != NULL) {
		generate_prototype(stubsFile, current_function);
		fprintf(stubsFile, "\n");
		fprintf(stubsFile, "{\n");
		generate_parameter_buffers(stubsFile, current_function);
		allocate_parameter_buffers(stubsFile, current_function);
		generate_parameter_marshalling(stubsFile, current_function);
		generate_execute_call(stubsFile, current_function);
		generate_constraints(current_function);
		//generate_parameter_demarshalling(stubsFile, current_function);
		deallocate_parameter_buffers(stubsFile, current_function);
		fprintf(stubsFile, "}\n");
		fprintf(stubsFile, "\n");
		
		generate_worker_case(workerFile, current_function);
		
		generate_prototype(includeFile, current_function);
		fprintf(includeFile, ";\n");
		
		current_function = current_function->next_function;
	}
}

