/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf


#define ARGS_OFFSET 1


static FILE *stubsFile = NULL;
static FILE *workerFile = NULL;
static FILE *includeFile = NULL;
static char includeName[PATH_MAX];

static char *c_types[] = { "void", "char", "char", "boolean", "error", "short",
	"long", "int", "float", "double", "String", "String", "String", "error" };
static char *c_out_types[] = { "error", "char[]", "char[]", "boolean[]", "error",
	"short[]", "long[]", "int[]", "float[]", "double[]", "String", "String[]",
	"String[]", "error" };



void generate_java_prolog()
{
	char name[PATH_MAX];
	char *c;
	
	debug_printf("Generate prolog\n");
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, ".java", PATH_MAX);
	rename_if_clash(name);
	stubsFile = fopen(name, "w");
	if (stubsFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	//strncpy(name, get_filename_base(), PATH_MAX);
	//strncat(name, "Worker.java", PATH_MAX);
	strncpy(name, "Worker.java", PATH_MAX);
	rename_if_clash(name);
	workerFile = fopen(name, "w");
	if (workerFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	strncpy(includeName, get_filename_base(), PATH_MAX);
	strncat(includeName, "Ops", PATH_MAX);
	
	strncpy(name, includeName, PATH_MAX);
	strncat(name, ".java", PATH_MAX);
	rename_if_clash(name);
	includeFile = fopen(name, "w");
	if (includeFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}
	
	fprintf(stubsFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(stubsFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "public class %s implements %s\n", get_filename_base(), includeName);
	fprintf(stubsFile, "{\n");
	
	fprintf(workerFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(workerFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(workerFile, "\n\n");
	fprintf(workerFile, "public class Worker implements %s\n", includeName);
	fprintf(workerFile, "{\n");
	fprintf(workerFile, "  public static void main(String args[])\n");
	fprintf(workerFile, "  {\n");
	fprintf(workerFile, "    int opCod;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "    if (args.length < 6)\n");
	fprintf(workerFile, "    {\n");
	fprintf(workerFile, "      System.out.println(\"ERROR: Wrong arguments list passed to the worker\\n\");\n");
	fprintf(workerFile, "      System.exit(1);\n");
	fprintf(workerFile, "    }\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "    opCod = Integer.parseInt(args[1]);\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "    GSWorker.IniWorker(args);\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "    switch (opCod)\n");
	fprintf(workerFile, "    {\n");
	
	fprintf(includeFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(includeFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(includeFile, "\n\n");
	fprintf(includeFile, "public interface %s\n", includeName);
	fprintf(includeFile, "{\n");
}


void generate_java_epilogue(void)
{
	char *c;
	
	debug_printf("Generate epilogue\n");
	
	fprintf(stubsFile, "}\n");
	
	fprintf(workerFile, "    }\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "    GSWorker.EndWorker(args);\n");
	fprintf(workerFile, "  }\n");
	fprintf(workerFile, "}\n");
	
	fprintf(includeFile, "}\n");
	
	fclose(stubsFile);
	fclose(workerFile);
	fclose(includeFile);
}


static void generate_enum(FILE *outFile, function *first_function)
{
	function *func;
	int i = 0;
	
	func = first_function;
	while (func != NULL) {
		fprintf(outFile, "  int %sOp = %i;\n", func->name, i);
		func = func->next_function;
		i++;
	}
}


static void generate_prototype(FILE *outFile, function *current_function)
{
	argument *current_argument;

	fprintf(outFile, "  public static %s %s(",
		c_types[current_function->return_type], current_function->name);
	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		if (current_argument->dir == in_dir) {
			fprintf(outFile, "%s ", c_types[current_argument->type]);
		} else {
			fprintf(outFile, "%s ", c_out_types[current_argument->type]);
		}
		fprintf(outFile, "%s", current_argument->name);
		current_argument = current_argument->next_argument;
		if (current_argument != NULL) {
			fprintf(outFile, ", ");
		}
	}
	fprintf(outFile, ")");
}


static void generate_parameter_buffers(FILE *outFile, function *func)
{
	argument *arg;

	fprintf(outFile, "    /* Marshalling/Demarshalling buffers */\n");

	/* Declare buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
			case boolean_dt:
			case short_dt:
			case int_dt:
			case long_dt:
			case longlong_dt:
			case float_dt:
			case double_dt:
				fprintf(outFile, "    String buff_%s;\n", arg->name);
				break;
			case file_dt:
				/* No conversion needed */
				break;
			case string_dt:
			case wstring_dt:
				fprintf(outFile, "    String base64buff_%s;\n", arg->name);
				break;
			case void_dt:
			case any_dt:
			case null_dt:
			default:
				fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
				break;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}


static void generate_parameter_marshalling(FILE *outFile, function *func)
{
	argument *arg;
	
	fprintf(outFile, "    /* Parameter marshalling */\n");

	/* Convert input parameters */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "    buff_%s = String.valueOf(%s);\n",
						arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "    buff_%s = String.valueOf(%s);\n",
						arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "    buff_%s = Short.toString(%s);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "    buff_%s = Long.toString(%s);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "    buff_%s = Long.toString(%s);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "    buff_%s = Integer.toString(%s);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "    buff_%s = Float.toString(%s);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "    buff_%s = Double.toString(%s);\n", arg->name, arg->name);
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "    base64buff_%s = Base64.encode(%s);\n", arg->name, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		} else if (arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "    buff_%s = String.valueOf(%s[0]);\n",
						arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "    buff_%s = String.valueOf(%s[0]);\n",
						arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "    buff_%s = Short.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "    buff_%s = Long.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "    buff_%s = Long.toString(%s[0]);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "    buff_%s = Integer.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "    buff_%s = Float.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "    buff_%s = Double.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "    base64buff_%s = Base64.encode(%s[0]);\n", arg->name, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}	


static void generate_parameter_demarshalling(FILE *outFile, function *func)
{
	argument *arg;
	int need_demarshalling = 0;
	
	/* Check if we need to demarshall and thus the infamous barrier */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					need_demarshalling = 1;
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					need_demarshalling = 1;
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		}
		arg = arg->next_argument;
	}
	
	if (!need_demarshalling) return;
	
	fprintf(outFile, "    /* Parameter demarshalling */\n");

	/* Convert output parameters */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "    %s[0] = buff_%s.charAt(0);\n", arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "    %s[0] = Boolean.valueOf(buff_%s).booleanValue();\n", arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "    %s[0] = Short.parseShort(buff_%s);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "    %s[0] = Long.parseLong(buff_%s);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "    %s[0] = Long.parseLong(buff_%s);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "    %s[0] = Integer.parseInt(buff_%s);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "    %s[0] = Float.parseFloat(buff_%s);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "    %s[0] = Double.parseDouble(buff_%s);\n", arg->name, arg->name);
					break;
				case file_dt:
					/* No conversion needed */
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "    %s[0] = Base64.decode(base64buff_%s);\n", arg->name, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					fprintf(stderr, "Error: wrong argument type for function %s argument '%s'\n", func->name, arg->name);
					break;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
}	


/* Note: sets passing_order in each argument */
static void generate_execute_call(FILE *outFile, function *func)
{
	argument *arg;
	int input_files = 0;
	int input_generics = 0;
	int output_files = 0;
	int output_generics = 0;
	int arg_order = 1;

	/* Count argument types */
	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->dir) {
			case in_dir:
				if (arg->type == file_dt) {
					input_files++;
				} else {
					input_generics++;
				}
				break;
			case out_dir:
				if (arg->type == file_dt) {
					output_files++;
				} else {
					output_generics++;
				}
				break;
			case inout_dir:
				if (arg->type == file_dt) {
					input_files++;
					output_files++;
				} else {
					input_generics++;
					output_generics++;
				}
				break;
			default:
				;
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "    String pars[] = new String[%i];\n", func->exec_arg_count);
	
	/* Pass input files */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == in_dir || arg->dir == inout_dir) && arg->type == file_dt) {
			fprintf(outFile, "    pars[%i] = %s;\n", arg_order - 1, arg->name);
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass input generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == in_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "    pars[%i] = buff_%s;\n", arg_order - 1, arg->name);
					break; 
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "    pars[%i] = base64buff_%s;\n", arg_order - 1, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
			arg->passing_in_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass output files */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type == file_dt) {
			fprintf(outFile, "    pars[%i] = %s;\n", arg_order - 1, arg->name);
			arg->passing_out_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Pass output generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			arg->passing_out_order = arg_order;
			arg_order++;
		}
		arg = arg->next_argument;
	}
	
	/* Make Execute call */
	fprintf(outFile, "\n");
	fprintf(outFile, "    GSMaster.Execute(%sOp, %i, %i, %i, %i, pars);\n",
		func->name, input_files, input_generics, output_files, output_generics);
	fprintf(outFile, "\n");
	
	/* Recover output generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "    buff_%s = pars[%i];\n", arg->name, arg->passing_out_order - 1);
					break; 
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "    base64buff_%s = pars[%i];\n", arg->name, arg->passing_out_order - 1);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "\n");
}


/* Note: requires passing_(in/out)_order to be set (by generate_execute_call) */
static void generate_worker_case(FILE *outFile, function *func)
{
	argument *arg;
	int is_first_arg = 1;
	int arg_number;
	
	debug_printf("\n*** Function %s\n", func->name);
	
	fprintf(outFile, "      case %sOp:\n", func->name);
	fprintf(outFile, "\n");
	
	/* Declare out generic buffers */
	arg = func->first_argument;
	while (arg != NULL) {
		if ((arg->dir == out_dir || arg->dir == inout_dir) && arg->type != file_dt) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "        String buff_%s;\n", arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        String base64buff_%s;\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	/* Declare (demarshalled) generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "        char %s;\n", arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "        boolean %s;\n", arg->name);
					break;
				case short_dt:
					fprintf(outFile, "        short %s;\n", arg->name);
					break;
				case long_dt:
					fprintf(outFile, "        long %s;\n", arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "        long %s;\n", arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "        int %s;\n", arg->name);
					break;
				case float_dt:
					fprintf(outFile, "        float %s;\n", arg->name);
					break;
				case double_dt:
					fprintf(outFile, "        double %s;\n", arg->name);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        String %s;\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		else if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "        char %s[] = new char[1];\n", arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "        boolean %s[] = new boolean[1];\n", arg->name);
					break;
				case short_dt:
					fprintf(outFile, "        short %s[] = new short[1];\n", arg->name);
					break;
				case long_dt:
					fprintf(outFile, "        long %s[] = new long[1];\n", arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "        long %s[] = new long[1];\n", arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "        int %s[] = new int[1];\n", arg->name);
					break;
				case float_dt:
					fprintf(outFile, "        float %s[] = new float[1];\n", arg->name);
					break;
				case double_dt:
					fprintf(outFile, "        double %s[] = new double[1];\n", arg->name);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        String %s[] = new String[1];\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, "\n");
	
	/* Fill in and inout generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "        %s = args[%i].charAt(0);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case boolean_dt:
					fprintf(outFile, "        %s = Boolean.valueOf(args[%i]).booleanValue();\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case short_dt:
					fprintf(outFile, "        %s = Short.parseShort(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case long_dt:
					fprintf(outFile, "        %s = Long.parseLong(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case longlong_dt:
                                        fprintf(outFile, "        %s = Long.parseLong(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
                                        break;
				case int_dt:
					fprintf(outFile, "        %s = Integer.parseInt(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case float_dt:
					fprintf(outFile, "        %s = Float.parseFloat(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case double_dt:
					fprintf(outFile, "        %s = Double.parseDouble(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        %s = Base64.decode(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		else if (arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "        %s[0] = args[%i].charAt(0);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case boolean_dt:
					fprintf(outFile, "        %s[0] = Boolean.valueOf(args[%i]).booleanValue();\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case short_dt:
					fprintf(outFile, "        %s[0] = Short.parseShort(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case long_dt:
					fprintf(outFile, "        %s[0] = Long.parseLong(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case longlong_dt:
                                        fprintf(outFile, "        %s[0] = Long.parseLong(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
                                        break;
				case int_dt:
					fprintf(outFile, "        %s[0] = Integer.parseInt(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case float_dt:
					fprintf(outFile, "        %s[0] = Float.parseFloat(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case double_dt:
					fprintf(outFile, "        %s[0] = Double.parseDouble(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        %s[0] = Base64.decode(args[%i]);\n", arg->name, arg->passing_in_order + ARGS_OFFSET);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}

	/* Make the call */
	fprintf(outFile, "        %sImpl.%s(", get_filename_base(), func->name);

	arg = func->first_argument;
	while (arg != NULL) {
		if (is_first_arg) {
			is_first_arg = 0;
		} else {
			fprintf(outFile, ", ");
		}
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:	
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case file_dt:
					fprintf(outFile, "args[%i]", arg->passing_in_order + ARGS_OFFSET);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		else { /* out_dir || inout_dir */
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case file_dt:
					fprintf(outFile, "args[%i]", arg->passing_out_order + ARGS_OFFSET);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, ");\n");
	
	fprintf(outFile, "\n");
	
	/* Marshall out/inout generics */
	arg = func->first_argument;
	while (arg != NULL) {
		if (arg->dir == inout_dir || arg->dir == out_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "        buff_%s = String.valueOf(%s[0]);\n", arg->name, arg->name);
					break;
				case boolean_dt:
					fprintf(outFile, "        buff_%s = String.valueOf(%s[0]);\n", arg->name, arg->name);
					break;
				case short_dt:
					fprintf(outFile, "        buff_%s = Short.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case long_dt:
					fprintf(outFile, "        buff_%s = Long.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case longlong_dt:
                                        fprintf(outFile, "        buff_%s = Long.toString(%s[0]);\n", arg->name, arg->name);
                                        break;
				case int_dt:
					fprintf(outFile, "        buff_%s = Integer.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case float_dt:
					fprintf(outFile, "        buff_%s = Float.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case double_dt:
					fprintf(outFile, "        buff_%s = Double.toString(%s[0]);\n", arg->name, arg->name);
					break;
				case file_dt:
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "        base64buff_%s = Base64.encode(%s[0]);\n", arg->name, arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
				
		}
		arg = arg->next_argument;
	}

	/* Set generics in order */
	for (arg_number = 1; arg_number <= func->exec_arg_count; arg_number++)
	{
		arg = func->first_argument;
		while (arg != NULL) {
			if (arg->passing_out_order == arg_number &&
				(arg->dir == inout_dir || arg->dir == out_dir)) {
				switch (arg->type) {
					case char_dt:
					case wchar_dt:
					case boolean_dt:
					case short_dt:
					case long_dt:
					case longlong_dt:
					case int_dt:
					case float_dt:
					case double_dt:
						fprintf(outFile, "        GSWorker.LeaveDestGen(buff_%s);\n", arg->name);
						break;
					case file_dt:
						break;
					case string_dt:
					case wstring_dt:
						fprintf(outFile, "        GSWorker.LeaveDestGen(base64buff_%s);\n", arg->name);
						break;
					case void_dt:
					case any_dt:
					case null_dt:
					default:
						;
				}
			}
			arg = arg->next_argument;
		}
	}
	
	fprintf(outFile, "\n");
	fprintf(outFile, "        break;\n");
	fprintf(outFile, "\n");
}


void generate_java_body (void)
{
	function *current_function;
	
	debug_printf("Generate body\n");
	
	generate_enum(includeFile, get_first_function());
	
	current_function = get_first_function();
	while (current_function != NULL) {
		generate_prototype(stubsFile, current_function);
		fprintf(stubsFile, "\n");
		fprintf(stubsFile, "  {\n");
		generate_parameter_buffers(stubsFile, current_function);
		generate_parameter_marshalling(stubsFile, current_function);
		generate_execute_call(stubsFile, current_function);
		generate_parameter_demarshalling(stubsFile, current_function);
		fprintf(stubsFile, "  }\n");
		fprintf(stubsFile, "\n");
		
		generate_worker_case(workerFile, current_function);
		
		current_function = current_function->next_function;
	}
}

