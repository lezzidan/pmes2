/* Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "datatypes.h"
#include "semantic.h"
#include "backendlib.h"


#if 0 /* Unsupported on AIX */
#ifdef DEBUG
#define debug_printf(fmt, args...) printf(fmt, ## args)
#else
#define debug_printf(args...) {}
#endif
#endif

#ifndef DEBUG
#define DEBUG 0
#endif
#define debug_printf if (DEBUG) printf


#define ARGS_OFFSET 2


static FILE *includeFile = NULL;
static char includeName[PATH_MAX];

static char *swig_return_types[] = { "void", "char", "char", "int", "void *", "short",
	"long","longlong", "int", "float", "double", "char *", "char *", "char *", "error" };
static char *swig_in_types[] = { "error", "char", "char", "int", "void *", "short",
	"long", "longlong", "int", "float", "double", "char *GSIN", "char *GSIN", "char *GSIN", "error" };
static char *swig_inout_types[] = { "error", "char *GSINOUT", "char *GSINOUT", "bool *GSINOUT", "void *",
	"short *GSINOUT", "long *GSINOUT", "longlong *GSINOUT", "int *GSINOUT", "float *GSINOUT", "double *GSINOUT", "char *GSIN", "char *GSINOUT",
	"char *GSINOUT", "error" };
static char *swig_out_types[] = { "error", "char *GSOUT", "char *GSOUT", "bool *GSOUT", "void *",
	"short *GSOUT", "long *GSOUT", "longlong *GSOUT", "int *GSOUT", "float *GSOUT", "double *GSOUT", "char *GSIN",
	"char *GSOUT", "char *GSOUT", "error" };



void generate_swig_prolog()
{
	strncpy(includeName, get_filename_base(), PATH_MAX);
	strncat(includeName, ".i", PATH_MAX);
	rename_if_clash(includeName);
	includeFile = fopen(includeName, "w");
	if (includeFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", includeName);
		exit(1);
	}
	
	fprintf(includeFile, "/* This file contains a description for Swig. */\n");
	fprintf(includeFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(includeFile, "/* Generator component: $Id: swig-backend.c,v 1.4 2004/06/16 09:25:31 perez Exp $ */\n");
	fprintf(includeFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(includeFile, "\n");
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "extern \"C\" {\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");
#if 0
	fprintf(includeFile, "/* The actual functions must use this variable to return their error codes */\n");
	fprintf(includeFile, "extern int gs_result;\n");
	fprintf(includeFile, "\n");	
#endif
	
	fprintf(includeFile, "%%module %s\n", get_filename_base());
	fprintf(includeFile, "\n");
	fprintf(includeFile, "%%{\n");
	fprintf(includeFile, "#include \"%s.h\"\n", get_filename_base());
	fprintf(includeFile, "#include <GS_master.h>\n");
	fprintf(includeFile, "%%}\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "%%include typemaps.i\n");
	fprintf(includeFile, "%%include GStypemap.i\n");
	fprintf(includeFile, "\n");
	
}


void generate_swig_epilogue(void)
{
	debug_printf("Generate epilogue\n");
	
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifdef __cplusplus\n");
	fprintf(includeFile, "}\n");
	fprintf(includeFile, "#endif\n");
	fprintf(includeFile, "\n");
	
	fclose(includeFile);
}


static void generate_prototype(FILE *outFile, function *current_function)
{
	argument *current_argument;

	fprintf(outFile, "/* %s %s(",
		swig_return_types[current_function->return_type],
		current_function->name);
	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		fprintf(outFile, "%s", current_argument->name);
		current_argument = current_argument->next_argument;
		if (current_argument != NULL) {
			fprintf(outFile, ", ");
		}
	}
	fprintf(outFile, ") */\n");

	fprintf(outFile, "%s %s(",
		swig_return_types[current_function->return_type],
		current_function->name);
	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		switch (current_argument->dir) {
			case in_dir:
				fprintf(outFile, "%s ", swig_in_types[current_argument->type]);
				break;
			case out_dir:
				fprintf(outFile, "%s ", swig_out_types[current_argument->type]);
				break;
			case inout_dir:
				fprintf(outFile, "%s ", swig_inout_types[current_argument->type]);
				break;
			default:
				;
		}
		current_argument = current_argument->next_argument;
		if (current_argument != NULL) {
			fprintf(outFile, ", ");
		}
	}
	fprintf(outFile, ");\n");
}


void generate_swig_body(void)
{
	function *current_function;
	debug_printf("Generate body\n");
	
	current_function = get_first_function();
	while (current_function != NULL) {
		generate_prototype(includeFile, current_function);
		fprintf(includeFile, "\n");
		
		current_function = current_function->next_function;
	}
}

