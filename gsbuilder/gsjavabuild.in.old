# Copyright 2002-2007 Barcelona Supercomputing Center (www.bsc.es)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!@SH@

set -e

export PATH=@ac_rtpath@$PATH

function exittrap {
	rc=$?
	if test x"$rc" != x"0" ; then
		echo "ERROR: Command exited with status" $rc"." 1>&2
		exit $rc
	fi
}

trap exittrap 0


# message functions
usage() {

	echo  Usage\: `basename $0` \<action\> \<component\> \<appname\>
	echo ""
	echo "  Available actions:"
	echo "    copy         Setup a compilation environment for the component for customization."
	echo "    build        Build the selected component ."
	echo "    clean        Remove generated binaries."
	echo ""
	echo "  Available components:"
	echo "    master       Build or copy the master part."
	echo "    worker       Build or copy the worker part."
	echo "    all          Build or copy the master and workers parts."
	echo ""
	echo "  <appname> corresponds to the name of the application used for source files and IDL files."
	exit 1
}


error() {
	echo "An error occurred, please check the output."
	exit 1;
}

generate_workergs_script_sh_in() {
	{ @CAT@ <<EOF
#!@SH_noreplace@

. \${PWD}/config.worker

#zeropading of numbers in order to have fixed length callbacks
zeropad ()
{
	number=\$@;
	count=\$((padding_length - \${#number}));

	while [ \$count -ne 0 ]; do
		number=0\$number;
		count=\$((\$count - 1));
	done
	echo \$number;
}

# interrupt handling function. Notify master & then exit
killed ()
{
	echo Worker was signaled;
	notify \$@;
	@MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
EOF
        } | @SED@ -e "s/_noreplace//g" > workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                @RM_noreplace@ -rf \${TMPTASK}
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
	exit -1;
}

notify ()
{
EOF
} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
if [ x"@exec_environment@" == x"GRID" ]; then
	{ @CAT@ <<EOF
		notification="\`zeropad \$task_num\` \$1 \$2 \$3";
		command="\$SSH \$master @SH_noreplace@ -c \"echo \$notification > \$notification_pipe\"";
		execute_with_retries \$command || echo "FATAL ERROR : COULDN'T CONTACT MASTER";
EOF
	} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
elif [ x"@exec_environment@" == x"CLUSTER" ]; then
	{ @CAT@ <<EOF
        \${COMMAND} \$master \$task_num \$1 \$2 \$3 \$notification_port 
        return \$?
EOF
        }| @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
elif [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        \${COMMAND} \$master \$task_num \$1 \$2 \$3 \$notification_port 
        return \$?
EOF
        }| @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
fi
        { @CAT@ <<EOF
}

execute_binary ()
{
        tid="task\${zeropadded_task_num}";
        TMPDIRECTORY='';
	( TMPDIRECTORY=\`@MKTEMP_noreplace@ -d -p\${TMPTASK}\` &&
                  cd \${TMPDIRECTORY} && @MKDIR_noreplace@ .gs_\${master_pid}_dir &&
                  @LN_noreplace@ -s \${workerdir}/\${EXECUTABLE} \${EXECUTABLE} &&
                  \${COMMAND} \$@ &&
                  cd - &&
                  @RM_noreplace@ -rf \${TMPDIRECTORY}
        ) 1>>\${TMPTASK}/\${tid}.out 2>>\${TMPTASK}/\${tid}.err
                result=\$?;
        return \${result};
}

execute_with_retries ()
{
	retries=0;
	command=\$@;
	while [ \$retries -ne \$max_retries ]; do
		\$command 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err && return 0;
		@SLEEP_noreplace@ \$((5 + \${retries}*\${RANDOM} % \${max_time_before_retry}));
		retries=\$((\$retries+1));
	done
	return -1;
}

# function to compare is workerdir is the same as masterdir
are_the_same()
{
        A="\$1";
        AA="\$1/";
        B="\$2";
        BB="\$2/";
        if test \${A} == \${B}; then
                return 0;
        elif test \${A} == \${BB}; then
                return 0;
        elif test \${AA} == \${B}; then
                return 0;
        elif test \${AA} == \${BB}; then
                return 0;
        else
                return -1;
        fi
}

EOF
} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;


if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        echo "gs_exec_env=\$1;" >> workerGS_script.sh.in;
        echo "shift 1;" >> workerGS_script.sh.in;
fi
        { @CAT@ <<EOF
# read arguments
cd \$1;
mode=\$2;
logs=\$3;
master_src_dir=\$4;
EOF
} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;

if [ x"@exec_environment@" == x"CLUSTER" ]; then
	echo "notification_port=\$5" >> workerGS_script.sh.in;
	echo "TMPTASK=\${TMPPREFIX}" >> workerGS_script.sh.in;
elif [ x"@exec_environment@" == x"GRID" ]; then
	echo "notification_pipe=\$5" >> workerGS_script.sh.in;
	echo "TMPTASK=\${TMPPREFIX}" >> workerGS_script.sh.in;
elif [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
notification_port=\$5

if [ \$gs_exec_env -eq \$ENV_GPFS ]; then
        TMPTASK=\${TMPPREFIX};
else
        TMPTASK=\`@MKTEMP_noreplace@ -d -p\${TMPPREFIX}\`;
fi

EOF
} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;

fi
	{ @CAT@ <<EOF
master_pid=\$6
shift 6;

workerdir=\${PWD};

if are_the_same \${workerdir} \${TMPTASK}; then
        samedir=1;
else
        samedir=0;
fi

if [ \$mode -eq \$EXECUTE ]; then 
	# read numers of files to be cleaned up and staged in
	nstagein=\$1;
	cleanup_files_num=\$2;
	shift 2;

	# builds the string holding the files to be staged in
	i=0;
	while [ \$i -lt \$nstagein ]; do
		input_files="\$input_files \$1 \$2";
		shift 2;
		i=\$((\$i+1));
	done
	i=0;

	# builds a string holding the files to be cleaned up
	while [ \$i -lt \$cleanup_files_num ]; do
		rmfiles="\$rmfiles \$1";
		shift;
		i=\$((\$i+1));
	done

	# read number of input/output files & master hostname( indexed backwards )
	j=0;
	for i in \$@; do
		args[\$j]=\$i;
		j=\$((\$j+1));
	done
	
	total_args=\$j
        master_pid=\${args[\$j-1]}
        input_files_num=\${args[\$j-6]}
        output_files_num=\${args[\$j-5]}
        master=\${args[\$j-4]}
	task_num=\${args[0]}
	zeropadded_task_num="\`zeropad \$task_num\`_\${master_pid}"
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                if test ! -e "\${TMPTASK}/.gs_\${master_pid}_dir"; then
                        @MKDIR_noreplace@ \${TMPTASK}/.gs_\${master_pid}_dir;
                fi
        else
                if test ! -e "\${workerdir}/.gs_\${master_pid}_dir"; then
                        @MKDIR_noreplace@ \${workerdir}/.gs_\${master_pid}_dir;
                fi
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
        { @CAT@ <<EOF
        if test ! -e "\${workerdir}/.gs_\${master_pid}_dir"; then
                @MKDIR_noreplace@ \${workerdir}/.gs_\${master_pid}_dir;
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
	# trap SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGXCPU
        trap "killed \$USER_CANCEL \$TASK_ENDS" 1 2 3 15;
        trap "killed \$QSYS_CANCEL \$TASK_ENDS" 24;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                i=0;
                #TMPTASK=\`@MKTEMP_noreplace@ -d -p\${TMPPREFIX}\`
                while [ \$i -lt \$output_files_num ]; do
                        args[\$j-7-\$i]="\${TMPTASK}/\${args[\$j-7-\$i]}";
                        if [ \$i -eq 0 ]; then
                                output_files="\${args[\$j-7-\$i]}";
                        else
                                output_files="\$output_files \${args[\$j-7-\$i]}";
                        fi
                        i=\$((\$i+1));
                done

                args[\$j-2]="\${workerdir}";
                #creating Temporal directory
                #TMPDIRECTORY=''
                #TMPDIRECTORY=\`@MKTEMP_noreplace@ -d -p\${TMPTASK}\`
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
	#remove logs from previous executions
	if [ \$logs == 1 ]; then
		@RM_noreplace@ -f task\${zeropadded_task_num}.out task\${zeropadded_task_num}.err task_clean_up.out task_clean_up.err;
	else
		@RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err
	fi

	# trap SIGHUP, SIGINT, SIGQUIT, SIGTERM
	# trap "killed \$USER_CANCEL \$TASK_ENDS" 1 2 3 15;

	# stage in files
	echo File Stage in ... 1>>\${TMPTASK}/task\${zeropadded_task_num}.out
	j=0;
	for i in \$input_files; do
		if [ \$j -eq 1 ]; then
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                                files="\$files \${TMPTASK}/\$i"
                        else
                                files="\$files \${PWD}/\$i"
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
        { @CAT@ <<EOF
                        files="\$files \${PWD}/\$i";
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF			
			j=0;
			echo STFile: \$SCP \$SCP_FLAGS \$files  1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
			execute_with_retries \$SCP \$SCP_FLAGS \$files; 
			if [ \$? -ne 0 ]; then
				notify \$STAGEIN_ERROR \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                                if [ \$samedir -eq 0 ]; then
                                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                                        @RM_noreplace@ -rf \${TMPTASK}
                                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
				exit -1;
			fi
		else
			files="\$i";
			j=1;
		fi
	done

	# notify for active state
	if ! notify \$TASK_ACTIVE \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err; then
                echo Error sending Notification task active.retrying... 1>>\${TMPTASK}/task\${zeropadded_task_num}.err
                @SLEEP_noreplace@ 5;
                if ! notify \$TASK_ACTIVE \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err; then
                        echo Error sending Notification task active.  1>>\${TMPTASK}/task\${zeropadded_task_num}.err
                        if [ \$samedir -eq 0 ]; then
                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                                @RM_noreplace@ -rf \${TMPTASK}
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                        exit -1;
                fi
        fi	

	# check if number of arguments is ok */
	if test ! -e "\${EXECUTABLE}"; then 
		notify \$WORKER_EXEC_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK};
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
		exit -1;
	fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                i=0;
                while [ \$i -lt \$input_files_num ]; do
                        args[\$i+2]="\${TMPTASK}/\${args[\$i+2]}";
                        i=\$((\$i+1));
                done
        fi
        i=0;
        while [ \$i -lt \$total_args ]; do
                if [ \$i -eq 0 ]; then
                        param="\${args[\$i]}";
                else
                        param="\${param} \${args[\$i]}";
                fi
                i=\$((\$i+1));
        done
        echo Executing binary \${param}... 1>>\${TMPTASK}/task\${zeropadded_task_num}.out
        if ! execute_binary \${param}; then
                notify \$WORKER_ERROR \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                fi
                exit -1;
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
        { @CAT@ <<EOF
        echo Executing binary \$@... 1>>\${TMPTASK}/task\${zeropadded_task_num}.out
        if ! execute_binary \$@; then
                notify \$WORKER_ERROR \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
	if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                exit -1;
        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
	{ @CAT@ <<EOF
        if test ! -f "\${PWD}/destGen_\${master_pid}_.\$task_num"; then
                notify \$DESTGEN_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                exit -1;
        fi
        echo Stage Out... 1>>\${TMPTASK}/task\${zeropadded_task_num}.out
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"GRID" ]; then
        { @CAT@ <<EOF
                if ! execute_with_retries "\$SCP \$SCP_FLAGS \${PWD}/destGen_\${master_pid}_.\$task_num \$master:\${master_src_dir}/.gs_\${master_pid}_dir"; then
                        notify \$DESTGEN_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                        if [ \$samedir -eq 0 ]; then
                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                        fi
                        exit -1;
                else
                        @RM_noreplace@ -f \${PWD}/destGen_\${master_pid}_.\$task_num;
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
	elif [ x"@exec_environment@" == x"CLUSTER" ]; then
        { @CAT@ <<EOF

                #if ! are_the_same \${PWD} \${master_src_dir}; then
                        echo "Worker and master directories are not the same destGen file transfer is needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;

                        if ! execute_with_retries "\$SCP \$SCP_FLAGS \${PWD}/destGen_\${master_pid}_.\$task_num \${master_src_dir}/.gs_\${master_pid}_dir"; then
                                notify \$DESTGEN_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err:
                                if [ \$samedir -eq 0 ]; then
                                       @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                                fi
                                exit -1;
                        else
                                @RM_noreplace@ -f \${PWD}/destGen_\${master_pid}_.\$task_num;
                        fi
                #else
                        echo "Worker and master directories are the same destGen file transfer is not needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                #fi

EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
	elif [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then

                        for i in \$output_files; do
                                echo STOut:\$SCP \$SCP_FLAGS \$i \${master_src_dir}/.gs_\${master_pid}_dir/ 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                                if ! execute_with_retries "\$SCP \$SCP_FLAGS \$i \${master_src_dir}/.gs_\${master_pid}_dir/"; then

                                        notify \$STAGEOUT_ERROR \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                                        if [ \$samedir -eq 0 ]; then
                                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                                        fi
                                        @RM_noreplace@ -rf \${TMPTASK}
                                        exit -1;
                                fi
                        done
                        #if ! are_the_same \${workerdir} \${master_src_dir}; then
                                echo "Worker and master directories are not the same destGen file transfer is needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                                if ! execute_with_retries "\$SCP \$SCP_FLAGS \${workerdir}/destGen_\${master_pid}_.\$task_num \${master_src_dir}/.gs_\${master_pid}_dir/"; then
                                        notify \$DESTGEN_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                                        if [ \$samedir -eq 0 ]; then
                                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                                        fi
                                        @RM_noreplace@ -rf \${TMPTASK}
                                        exit -1;
                                else
                                        @RM_noreplace@ -f \${workerdir}/destGen_\${master_pid}_.\$task_num;
                                fi
                        #else
                                #echo "Worker and master directories are the same destGen file transfer is not needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                        #fi
                else

			#if ! are_the_same \${PWD} \${master_src_dir}; then
                                echo "Worker and master directories are not the same destGen file transfer is needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                                if ! execute_with_retries "\$SCP \$SCP_FLAGS \${PWD}/destGen_\${master_pid}_.\$task_num \${master_src_dir}/.gs_\${master_pid}_dir/"; then
                                        notify \$DESTGEN_NF \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                                        if [ \$samedir -eq 0 ]; then
                                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                                        fi
                                        exit -1;
                                else
                                        @RM_noreplace@ -f \${PWD}/destGen_\${master_pid}_.\$task_num;
                                fi
                        #else
                                #echo "Worker and master directories are the same destGen file transfer is not needed..." 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
                        #fi
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
	{ @CAT@ <<EOF
	# cleanup phase
	for i in \$rmfiles; do
		@RM_noreplace@ -f \$i;
	done
	echo Task Done ... 1>>\${TMPTASK}/task\${zeropadded_task_num}.out
        if ! notify \$TASK_DONE \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err; then
                echo Error sending Notification task done. Retrying... 1>>\${TMPTASK}/task\${zeropadded_task_num}.err
                @SLEEP_noreplace@ 5;
                if ! notify \$TASK_DONE \$TASK_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err; then
                        echo Error sending Notification task done. 1>>\${TMPTASK}/task\${zeropadded_task_num}.err
                        if [ \$samedir -eq 0 ]; then
                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                                @RM_noreplace@ -rf \${TMPTASK}
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                        exit -1;
                fi
        fi
        if [ \$logs -eq 0 ]; then
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                else
                        @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
        { @CAT@ <<EOF
                @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
        else
           if [ \$logs -eq 1 ]; then
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi

EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
	if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                else
                        if [ \$samedir -eq 0 ]; then
                                @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
                        fi
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                fi
        fi	

elif [ \$mode -eq \$CLEANUP ]; then
        master=\$1;
        task_num=\$2;
	is_masterdisk=\$3
        num_of_stageout=\$4;
        i=0;
        zeropadded_task_num="\`zeropad \$task_num\`_\${master_pid}.stageout"
        shift 4;
	
	while [ \$i -lt \$num_of_stageout ]; do 
EOF
	} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
		if [ x"@exec_environment@" == x"GRID" ]; then
                        echo "			command=\"\$SCP \$SCP_FLAGS \${PWD}/\$1 \$master:\$2\"" >> workerGS_script.sh.in;
		elif [ x"@exec_environment@" == x"CLUSTER" ]; then
                        echo "			command=\"\$SCP \$SCP_FLAGS \${PWD}/\$1 \$2\"" >> workerGS_script.sh.in;
		elif [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
			echo "                  if [ \$gs_exec_env -eq \$ENV_GPFS ]; then" >> workerGS_script.sh.in;
                        echo "           		command=\"\$SCP \$SCP_FLAGS \${PWD}/\$1 \$2\"" >> workerGS_script.sh.in;
			echo "		 		echo \"cleanup:\$SCP \$SCP_FLAGS \${PWD}/\$1 \$2\" 1>>\${TMPTASK}/task\${zeropadded_task_num}.out" >> workerGS_script.sh.in; 		
                        echo "			fi" >> workerGS_script.sh.in;
		fi		
	{ @CAT@ <<EOF
		if ! execute_with_retries \$command; then
                        notify \$CLEANUP_ERROR \$RM_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
                        if [ \$samedir -eq 0 ]; then
                                @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                        fi
                        exit -1;
                fi
		shift 2;
		i=\$((\$i+1));
	done
	if [ \$task_num -eq \$CLEANUP_TASK ]; then
		for i in \$@; do
			echo "\${workerdir}/.gs_\${master_pid}_dir/\$i" 1>>\${TMPTASK}/task\${zeropadded_task_num}.out;
			@RM_noreplace@ -f \${workerdir}/.gs_\${master_pid}_dir/\$i;
		done
		if [ \$is_masterdisk -eq \$ISNOTMASTER ]; then
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                	if [ \$gs_exec_env -eq \$ENV_GPFS ]; then
                        	if test -e "\${workerdir}/.gs_\${master_pid}_dir"; then
                                	@RM_noreplace@ -rf \${workerdir}/.gs_\${master_pid}_dir;
                        	fi
                	fi
	fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
	{ @CAT@ <<EOF
			if test -e "\${workerdir}/.gs_\${master_pid}_dir"; then
				@RM_noreplace@ -rf \${workerdir}/.gs_\${master_pid}_dir;
                	fi
	fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;	
	fi
        { @CAT@ <<EOF
        fi
	notify \$CLEANUP_DONE \$RM_ENDS 1>>\${TMPTASK}/task\${zeropadded_task_num}.out 2>>\${TMPTASK}/task\${zeropadded_task_num}.err;
	if [ \$logs -eq 0 ]; then
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                else
                        @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        else
        { @CAT@ <<EOF
                @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
	else
           if [ \$logs -eq 1 ]; then
                if [ \$samedir -eq 0 ]; then
                        @MV_noreplace@ \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err \${workerdir};
                fi

EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                if [ \$gs_exec_env -eq \$ENV_SCRATCH ]; then
                        @RM_noreplace@ -rf \${TMPTASK}
                else
                        if [ \$samedir -eq 0 ]; then
                                @RM_noreplace@ -f \${TMPTASK}/task\${zeropadded_task_num}.out \${TMPTASK}/task\${zeropadded_task_num}.err;
                        fi
                fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
        fi
        { @CAT@ <<EOF
                fi
        fi 
elif [ \$mode -eq \$NOTIFY ]; then
        master=\$1;
        task_num=\$2;
        zeropadded_task_num=\`zeropad \$task_num\`
        notify \$QSUB_ERROR \$TASK_ENDS;
fi

EOF
	} | @SED@ -e "s/_noreplace//g" >> workerGS_script.sh.in;
}

generate_workergs_sh_PBS() {

        queue_submit_com=$1;
	{ @CAT@ <<EOF
#!@SH_noreplace@
EOF
        } | @SED@ -e "s/_noreplace//g" > workerGS.sh.in;

if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
gs_exec_env=\$1;
shift 1;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
task_num=\$1;
queue=\$2;
wc_limit=\$3;
shift 3;
master_pid=\$6

cd \$1;

. \${PWD}/config.worker;

EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \${gs_exec_env} \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
	{ @CAT@ <<EOF
        else
        {
                @CAT_noreplace@ <<EOT
                        #!@CSH_noreplace@
                        ## JobName
                        #PBS -N GS.\$task_num
                        ## Job is not re-runable
                        #PBS -r n
                        ## Outputs
                        #PBS -e GS.\${task_num}_\${master_pid}.err
                        #PBS -o GS.\${task_num}_\${master_pid}.out
                        # export all my environment variables to the job
                        #PBS -V
                        #########

                        # change to working directory
                        cd \$1
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF

                        ./workerGS_script.sh \${gs_exec_env} \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF
                        ./workerGS_script.sh \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
EOT
        } | exec $queue_submit_com -q \$queue 1>subtsk\${task_num}_\${master_pid}.out 2>subtsk\${task_num}_\${master_pid}.err
	result=\$?;
                if [ \$result -eq 0 ]; then
                        @RM_noreplace@ -f subtsk\${task_num}_\${master_pid}.out subtsk\${task_num}_\${master_pid}.err;
                else
                        # Notify error in submit

                        mode=\$2;
                        if [ \$mode -eq \$EXECUTE ]; then

                                nstagein=\$7;
                                cleanup_files_num=\$8;
                                let "t=8+(2*\$nstagein)+\$cleanup_files_num";

                                j=0;
                                for i in \$@; do
                                        args[\$j]=\$i;
                                        j=\$((\$j+1));
                                done


                                master=\${args[\$j-4]};
                                task_num=\${args[\$t]};

                        elif [ \$mode -eq \$CLEANUP ]; then
                                master=\$7;
                                task_num=\$8;
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        exec ./workerGS_script.sh \${gs_exec_env} \$1 2 \$3 \$4 \$5 \$6\$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>subtsk\${task_num}_\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
{ @CAT@ <<EOF
                        exec ./workerGS_script.sh \$1 2 \$3 \$4 \$5 \$6 \$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>subtsk\${task_num}_\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
{ @CAT@ <<EOF
                fi
        fi



EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;	
}

generate_workergs_sh_LL() {

        queue_submit_com=$1;

        { @CAT@ <<EOF
#!@SH_noreplace@
EOF
        } | @SED@ -e "s/_noreplace//g" > workerGS.sh.in;

if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
gs_exec_env=\$1;
shift 1;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
task_num=\$1;
queue=\$2;
wc_limit=\$3;
if [ x\$wc_limit != x"unlimited" ]; then
        WC_LIMIT_arg=\`echo \${wc_limit} | @SED_noreplace@ -e 's/:/ /g'\`;
                                        j=0;
                                        for i in \$WC_LIMIT_arg; do
                                                if [ \$j = 0 ]; then
                                                        WC_LIMIT=\$i;
                                                elif [ \$j = 1 ]; then
                                                        min=\$((\$i+1));
                                                        WC_LIMIT=\${WC_LIMIT}:\$min;
                                                elif [ \$j = 2 ]; then
                                                        WC_LIMIT=\${WC_LIMIT}:\$i,\${wc_limit};
                                                else
                                                        echo "Bad definition of walk_limit_clock";
                                                fi
                                                j=\$((\$j+1));
                                        done
fi
shift 3;

cd \$1;

. \${PWD}/config.worker;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \${gs_exec_env} \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
        else
                {
                @CAT_noreplace@ <<EOT
                        # @ shell = @BASH_noreplace@
                        # @ job_type = serial
                        # @ job_name = GS.\${task_num}.\${master_pid}
                        # @ output = GS.\${task_num}_\${master_pid}.out
                        # @ error = GS.\${task_num}_\${master_pid}.err
                        # @ initialdir = \$1
                        # @ class = \${queue}
                        # @ wall_clock_limit= \${WC_LIMIT}
                        # @ group = \`id -gn\`
                        ## @ node = 1
                        ## @ total_tasks = 1
                        # @ queue

                        cd \$1;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF

                        ./workerGS_script.sh \${gs_exec_env} \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF
                        ./workerGS_script.sh \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
EOT
                } | exec $queue_submit_com - 1>subtsk\${task_num}_\${master_pid}.out 2>subtsk\${task_num}_\${master_pid}.err
                result=\$?;
                if [ \$result -eq 0 ]; then
                        @RM_noreplace@ -f subtsk\${task_num}_\${master_pid}.out subtsk\${task_num}_\${master_pid}.err;
                else
                        # Notify error in submit

                        mode=\$2;
                        if [ \$mode -eq \$EXECUTE ]; then

                                nstagein=\$7;
                                cleanup_files_num=\$8;
                                let "t=8+(2*\$nstagein)+\$cleanup_files_num";

                                j=0;
                                for i in \$@; do
                                        args[\$j]=\$i;
                                        j=\$((\$j+1));
                                done


                                master=\${args[\$j-4]};
                                task_num=\${args[\$t]};

                        elif [ \$mode -eq \$CLEANUP ]; then
                                master=\$7;
                                task_num=\$8;
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        exec ./workerGS_script.sh \${gs_exec_env} \$1 2 \$3 \$4 \$5 \$6 \$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>subtsk\${task_num}_\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
{ @CAT@ <<EOF
                        exec ./workerGS_script.sh \$1 2 \$3 \$4 \$5 \$6 \$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>subtsk\${task_num}_\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
{ @CAT@ <<EOF
                fi
        fi



EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
}
generate_workergs_sh_MN() {

        queue_submit_com=$1;

        { @CAT@ <<EOF
#!@SH_noreplace@
EOF
        } | @SED@ -e "s/_noreplace//g" > workerGS.sh.in;

if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
gs_exec_env=\$1;
shift 1;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
task_num=\$1;
queue=\$2;
wc_limit=\$3;
shift 3;
master_pid=\$6
cd \$1;

. \${PWD}/config.worker;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \${gs_exec_env} \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF
        if [ x\$queue = x"none" ]; then
                exec \${PWD}/workerGS_script.sh \$@ 2>/dev/null 1>/dev/null &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
        else
                {
                @CAT_noreplace@ > /scratch/tmp/submit_\${task_num}_\${master_pid} <<EOT
#!@BASH_noreplace@
# @ job_type = serial
# @ job_name = GS.\${task_num}.\${master_pid}
# @ output = GS.\${task_num}_\${master_pid}.out
# @ error = GS.\${task_num}_\${master_pid}.err
# @ initialdir = \$1
# @ class = \${queue}
# @ wall_clock_limit= \${wc_limit}
# @ group = \`id -gn\`
# @ queue

        cd \$1;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF

        ./workerGS_script.sh \${gs_exec_env} \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;

EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
        { @CAT@ <<EOF

        ./workerGS_script.sh \$@ && @RM_noreplace@ -f GS.\${task_num}_\${master_pid}.out GS.\${task_num}_\${master_pid}.err;
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
        { @CAT@ <<EOF
EOT
                } | exec $queue_submit_com /scratch/tmp/submit_\${task_num}_\${master_pid} 1>subtsk\${task_num}_\${master_pid}.out 2>subtsk\${task_num}_\${master_pid}.err
                result=\$?;
                if [ \$result -eq 0 ]; then
                        @RM_noreplace@ -f subtsk\${task_num}_\${master_pid}.out subtsk\${task_num}_\${master_pid}.err /scratch/tmp/submit_${task_num}_${master_pid};
                else
                        # Notify error in submit
                        @MV_noreplace@ /scratch/tmp/submit_\${task_num}_\${master_pid} .
                        mode=\$2;
                        if [ \$mode -eq \$EXECUTE ]; then

                                nstagein=\$7;
                                cleanup_files_num=\$8;
                                let "t=8+(2*\$nstagein)+\$cleanup_files_num";

                                j=0;
                                for i in \$@; do
                                        args[\$j]=\$i;
                                        j=\$((\$j+1));
                                done

                                master=\${args[\$j-4]};
                                task_num=\${args[\$t]};

                        elif [ \$mode -eq \$CLEANUP ]; then
                                master=\$7;
                                task_num=\$8;
                        fi
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
        { @CAT@ <<EOF
                        exec ./workerGS_script.sh \${gs_exec_env} \$1 2 \$3 \$4 \$5 \$6 \$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>sub
tsk\${task_num}_\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
else
{ @CAT@ <<EOF
                        exec ./workerGS_script.sh \$1 2 \$3 \$4 \$5 \$6 \$master \$task_num 2>>subtsk\${task_num}_\${master_pid}.err 1>>subtsk\${task_num}_
\${master_pid}.out &
EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
fi
{ @CAT@ <<EOF
                fi
        fi



EOF
        } | @SED@ -e "s/_noreplace//g" >> workerGS.sh.in;
}

generate_autogen_sh() {
        @CAT@ > autogen.sh << EOF
#!@SH@
set -e

export CC="@CC@"
export CXX="@CXX@"

@ACLOCAL@
@AUTOMAKE@ -a -c
@AUTOCONF@
./configure --with-gs-prefix=@prefix@ $*

for script in workerGS.sh workerGS_script.sh config_worker.sh config_master.sh ssh_execute.sh config_all.sh; do
	if ( test -e \$script && ! test -x \$script ); then
		@CHMOD@ +x \$script;
	fi
done

EOF
        @CHMOD@ +x autogen.sh
}

# master functions
prepare_master_build() {
	gsprefix=$1
	appname=$2
	if test -d gsbuild ; then
		echo "The gsbuild directory already exists from a previous build. Removing."
		@RM@ -rf gsbuild
	fi

	@MKDIR@ gsbuild
	cd gsbuild
	@LN_S@ -f ../*.java .
	@LN_S@ -f ../*.jar .
	@LN_S@ -f ../*.idl .
	@LN_S@ -f ../*.h .
	@LN_S@ -f @prefix@/etc/gss-master-env.sh .
	@LN_S@ -f @prefix@/etc/gss-master-env.csh .
}

copy_master_build_env() {
	gsprefix=$1
	appname=$2
	@CP@ @prefix@/share/gridsuperscalar/build/java/master/Makefile.am Makefile.am.source
	@CAT@ @prefix@/share/gridsuperscalar/build/java/master/configure.in | @SED@ -e s/PACKAGE/"$appname"/g |
                                                                        @SED@ -e s/CLASSADS_SUPPORT/"@with_classads@"/g > configure.in
	@CAT@ Makefile.am.source | @SED@ 's/PACKAGE/'$appname'/g' > Makefile.am
	generate_autogen_sh 
	@TOUCH@	NEWS README AUTHORS ChangeLog
	echo "" > empty.cc

	path_to_dist="@prefix@";
	path_to_dist=$(echo $path_to_dist | @SED@ 's/\//\\\//g')
	copy_comm="@copy_command@";
	copy_comm=$(echo $copy_comm | @SED@ 's/\//\\\//g');
	copy_comm_flags="@copy_command_flags@";
	copy_comm_flags=$(echo $copy_comm_flags | @SED@ 's/\//\\\//g');

	@CAT@ @prefix@/share/gridsuperscalar/build/java/master/config_master.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
		@SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
		@SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_master.sh.in;
}

build_master() {
	gsprefix=$1
	appname=$2
	./autogen.sh
	@MAKE@
}

finish_master_build() {
	gsprefix=$1
	appname=$2
	@CP@ -f *.class ..
	@CP@ -f config_master.sh ..

        cd ..
        @RM@ -rf gsbuild
        @RM@ -f config_master.sh.in
}

clean_master() {
	@RM@ -f $appname gss-master-env.sh gss-master-env.csh || exit
}
# all functions
prepare_all_build() {
        gsprefix=$1
        appname=$2
        if test -d gsbuild ; then
                echo "The gsbuild directory already exists from a previous build. Removing."
                @RM@ -rf gsbuild
        fi

        @MKDIR@ gsbuild
        cd gsbuild
        @LN_S@ -f ../*.java .
        @LN_S@ -f ../*.jar .
        @LN_S@ -f ../*.idl .
        @LN_S@ -f ../*.h .
        @LN_S@ -f @prefix@/etc/gss-master-env.sh .
        @LN_S@ -f @prefix@/etc/gss-master-env.csh .
	@LN_S@ -f ../workerGS_script.sh.in .
        @LN_S@ -f ../workerGS.sh.in .
        @LN_S@ -f ../config_worker.sh.in .
}
copy_all_build_env() {
        gsprefix=$1
        appname=$2
        @CP@ @prefix@/share/gridsuperscalar/build/java/all/Makefile.am Makefile.am.source
        @CAT@ @prefix@/share/gridsuperscalar/build/java/all/configure.in | @SED@ -e s/PACKAGE/"$appname"/g |
                                                                        @SED@ -e s/CLASSADS_SUPPORT/"@with_classads@"/g > configure.in
        @CAT@ Makefile.am.source | @SED@ 's/PACKAGE/'$appname'/g' > Makefile.am
        generate_autogen_sh
        @TOUCH@ NEWS README AUTHORS ChangeLog
        echo "" > empty.cc

        path_to_dist="@prefix@";
        path_to_dist=$(echo $path_to_dist | @SED@ 's/\//\\\//g')
        copy_comm="@copy_command@";
        copy_comm=$(echo $copy_comm | @SED@ 's/\//\\\//g');
        copy_comm_flags="@copy_command_flags@";
        copy_comm_flags=$(echo $copy_comm_flags | @SED@ 's/\//\\\//g');

        @CAT@ @prefix@/share/gridsuperscalar/build/java/all/config_all.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
                @SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
                @SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_all.sh.in;
	@CAT@ @prefix@/share/gridsuperscalar/build/java/master/config_master.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
                @SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
                @SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_master.sh.in;
	@CAT@ @prefix@/share/gridsuperscalar/build/java/worker/config_worker.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
                @SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
                @SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_worker.sh.in;

        generate_workergs_script_sh_in
	if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
                if ! test x"@QUEUE_SUBMIT_MN@" = x"none" ; then
                        generate_workergs_sh_MN "@QUEUE_SUBMIT_MN@"
                else
                        generate_workergs_sh_LL "@QUEUE_SUBMIT_LL@"
                fi
        else
                if ! test x"@QUEUE_SUBMIT_PBS@" = x"none" ; then
                        generate_workergs_sh_PBS "@QUEUE_SUBMIT_PBS@"
                else
                        generate_workergs_sh_LL "@QUEUE_SUBMIT_LL@"
                fi
        fi

        @LN_S@ -f Worker.class workerGS
}
build_all() {
        gsprefix=$1
        appname=$2
        ./autogen.sh
        @MAKE@
}
finish_all_build() {
        gsprefix=$1
        appname=$2
        @CP@ -f *.class ..
        @CP@ -f config_master.sh ..
	@CP@ -f config_all.sh ..
	@CP@ -f config_worker.sh ..
        @CP@ -f workerGS.sh ..
        @CP@ -f workerGS_script.sh ..

        cd ..
        @RM@ -rf gsbuild
        @RM@ -f config_master.sh.in
	@RM@ -f config_all.sh.in
	@RM@ -f config_worker.sh.in
        @RM@ -f workerGS_script.sh.in
        @RM@ -f workerGS.sh.in

        @LN_S@ -f Worker.class workerGS
}
clean_all() {
        @RM@ -f $appname gss-master-env.sh gss-master-env.csh ${appname}Impl.class workerGS.sh || exit
	
}

build_all_script(){
        gsprefix=$1
        appname=$2

        if test -d gsbuild ; then
                echo "The gsbuild directory already exists from a previous build. Removing."
                @RM@ -rf gsbuild
        fi

        @MKDIR@ gsbuild
        cd gsbuild

        @CP@ @prefix@/share/gridsuperscalar/build/java/all/Makefile.am Makefile.am.source
        @CAT@ Makefile.am.source | @SED@ 's/PACKAGE/'$appname'/g' > Makefile.am
        @CAT@ @prefix@/share/gridsuperscalar/build/java/all/configure.in | @SED@ -e s/PACKAGE/"$appname"/g |
                                                                        @SED@ -e s/CLASSADS_SUPPORT/"@with_classads@"/g > configure.in
        #@CAT@ Makefile.am.source | @SED@ 's/PACKAGE/'$appname'/g' > Makefile.am
        
        @TOUCH@ NEWS README AUTHORS ChangeLog
        echo "" > empty.cc

        path_to_dist="@prefix@";
        path_to_dist=$(echo $path_to_dist | @SED@ 's/\//\\\//g')
        copy_comm="@copy_command@";
        copy_comm=$(echo $copy_comm | @SED@ 's/\//\\\//g');
        copy_comm_flags="@copy_command_flags@";
        copy_comm_flags=$(echo $copy_comm_flags | @SED@ 's/\//\\\//g');

        @CAT@ @prefix@/share/gridsuperscalar/build/java/all/config_all.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
                @SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
                @SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_all.sh.in;
        set -e

        #export CC="@CC@"
        #export CXX="@CXX@"
        echo "Autogen..";
        #
        
        @AUTOCONF@
        ./configure
        echo "Changing permisions...";
        @CHMOD@ +x config_all.sh
        @CP@ -f config_all.sh ..
        cd ..
        @RM@ -rf gsbuild
        @RM@ -f config_all.sh.in
}


# worker functions
prepare_worker_build() {
	gsprefix=$1
	appname=$2
	if test -d gsbuild ; then
		echo "The gsbuild directory already exists from a previous build. Removing."
		@RM@ -rf gsbuild
	fi

	@MKDIR@ gsbuild
	cd gsbuild
	@LN_S@ -f ../*.java .
	@LN_S@ -f ../*.jar .
	@LN_S@ -f ../*.idl .
	@LN_S@ -f ../*.h .
	@LN_S@ -f ../workerGS_script.sh.in .
        @LN_S@ -f ../workerGS.sh.in .
        @LN_S@ -f ../config_worker.sh.in .
}

copy_worker_build_env() {
	gsprefix=$1
	appname=$2
	@CP@ @prefix@/share/gridsuperscalar/build/java/worker/Makefile.am Makefile.am.source
	@CAT@ @prefix@/share/gridsuperscalar/build/java/worker/configure.in | @SED@ 's/PACKAGE/'$appname'/g' > configure.in
	@CAT@ Makefile.am.source | @SED@ 's/PACKAGE/'$appname'/g' > Makefile.am
	generate_autogen_sh
	@TOUCH@ NEWS README AUTHORS ChangeLog

	path_to_dist="@prefix@";
	path_to_dist=$(echo $path_to_dist | @SED@ 's/\//\\\//g')
	copy_comm="@copy_command@";
	copy_comm=$(echo $copy_comm | @SED@ 's/\//\\\//g');
	copy_comm_flags="@copy_command_flags@";
	copy_comm_flags=$(echo $copy_comm_flags | @SED@ 's/\//\\\//g');

	@CAT@ @prefix@/share/gridsuperscalar/build/java/worker/config_worker.sh.in | @SED@ 's/PACKAGE/'$path_to_dist'/g' |
		@SED@ -e s/_REMOTE_COPY_COMMAND_FLAGS_/"$copy_comm_flags"/ |
		@SED@ -e s/_REMOTE_COPY_COMMAND_/"$copy_comm"/ > config_worker.sh.in;

	generate_workergs_script_sh_in
	if [ x"@exec_environment@" == x"MN_SCRATCH" ]; then
                if ! test x"@QUEUE_SUBMIT_MN@" = x"none" ; then
                        generate_workergs_sh_MN "@QUEUE_SUBMIT_MN@"
                else
                        generate_workergs_sh_LL "@QUEUE_SUBMIT_LL@"
                fi
        else
                if ! test x"@QUEUE_SUBMIT_PBS@" = x"none" ; then
                        generate_workergs_sh_PBS "@QUEUE_SUBMIT_PBS@"
                else
                        generate_workergs_sh_LL "@QUEUE_SUBMIT_LL@"
                fi
        fi	
	
	@LN_S@ -f Worker.class workerGS
}

build_worker() {
	gsprefix=$1
	appname=$2
	./autogen.sh
	@MAKE@
}

finish_worker_build() {
	gsprefix=$1
	appname=$2
	@CP@ -f *.class ..
	@CP@ -f config_worker.sh ..
        @CP@ -f workerGS.sh ..
        @CP@ -f workerGS_script.sh ..

	cd ..
	@RM@ -rf gsbuild
	@RM@ -f config_worker.sh.in
        @RM@ -f workerGS_script.sh.in
        @RM@ -f workerGS.sh.in

	@LN_S@ -f Worker.class workerGS
}

clean_worker() {
	@RM@ -f ${appname}Impl.class workerGS.sh
}


# main code
if test $# != 3 ; then
	usage
fi

action=$1
component=$2
appname=$3

if test x"$GS_LOCATION" != x ; then
	echo "Using environment variable GS_LOCATION."
	gsprefix=$GS_LOCATION
else
	gsprefix=@prefix@
fi


case $action in
	copy)
		case $component in
			master)
				echo "Preparing master build environment"
				copy_master_build_env $gsprefix $appname
				;;
			worker)
				echo "Preparing worker build environment"
				copy_worker_build_env $gsprefix $appname
				;;
			all)
				echo "Cannot copy master and worker environment. Please, select master or worker only."
				;;
			*)
				usage
				;;
		esac
		;;
	build)
		case $component in
			master)
				echo "Building master"
				prepare_master_build $gsprefix $appname
				copy_master_build_env $gsprefix $appname
				build_master $gsprefix $appname
				finish_master_build $gsprefix $appname
				;;
			worker)
				echo "Building worker"
				prepare_worker_build $gsprefix $appname
				copy_worker_build_env $gsprefix $appname
				build_worker $gsprefix $appname
				finish_worker_build $gsprefix $appname
				;;
			all)
				echo "Building all"
				prepare_all_build $gsprefix $appname
				copy_all_build_env $gsprefix $appname
				build_all $gsprefix $appname
				finish_all_build $gsprefix $appname

				#echo "Building config_all script"
                                #build_all_script $gsprefix $appname
				;;
			*)
				usage
				;;
		esac
		;;
	clean)
		case $component in
			master)
				echo "Cleaning master"
				clean_master
				;;
			worker)
				echo "Cleaning worker"
				clean_worker
				;;
			all)
				echo "Cleaning master and worker"
				clean_master
				clean_worker
				;;
			*)
				usage
				;;
		esac
		;;
	*)
		usage
		;;
esac


echo "Command succesful."


